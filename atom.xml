<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[iginkgo在路上]]></title>
  <link href="iginkgo.cn/atom.xml" rel="self"/>
  <link href="iginkgo.cn/"/>
  <updated>2018-07-26T00:10:51+08:00</updated>
  <id>iginkgo.cn/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[fastlane相关]]></title>
    <link href="iginkgo.cn/15325341079693.html"/>
    <updated>2018-07-25T23:55:07+08:00</updated>
    <id>iginkgo.cn/15325341079693.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<p>具体的fastlane配置文件在 <code>项目/fastlane/</code>文件内 </p>

<pre><code>Fastfile =&gt; 用来定义所有的lane任务
Appfile =&gt; 是用来存储一些公共信息的，比如app_identifier，apple_id，team_id，itc_team_id等。
Deliverfile =&gt; deliver的配置文件
</code></pre>

<h2 id="toc_0">fastlane安装</h2>

<pre><code>xcode-select --install
sudo gem install fastlane
</code></pre>

<p>其中在安装fastlane时一直出现问题， 按照fastlane在github上给出的说明， 安装了RVM之后，安装的问题得以解决。</p>

<h2 id="toc_1">插件安装</h2>

<pre><code>fastlane install_plugins // 安装插件
</code></pre>

<p>当前项目中分别安装了两个插件</p>

<pre><code>fastlane add_plugin firim // 自动上传fir的插件
fastlane add_plugin versioning
</code></pre>

<h2 id="toc_2">使用</h2>

<p>在cocopods一下安装没有问题的情况下</p>

<p><code>fastlane develop</code> 打包development环境并进行上传<br/>
<code>fastlane adhoc</code>   打包adhoc环境并进行上传<br/>
 测试// 攻略中</p>

<h2 id="toc_3">参考文档</h2>

<ol>
<li><a href="https://docs.fastlane.tools/">官方文档</a></li>
<li><p><a href="https://dongjiawang.github.io/2017/09/13/2017-09-13-fastlane/">自动发布</a></p></li>
<li><p><a href="https://zhuanlan.zhihu.com/p/23180455">https://zhuanlan.zhihu.com/p/23180455</a></p></li>
<li><p>把所有的过程打包成一个可执行文件 <a href="https://www.jianshu.com/p/edcd8d9430f6">方法</a></p></li>
<li><p><a href="http://www.devzhang.cn/2017/07/18/fastLane%E5%85%A5%E9%97%A8%E4%B9%8Bipa%E6%89%93%E5%8C%85/">没事看看</a></p></li>
</ol>

<h2 id="toc_4">额外配置</h2>

<h3 id="toc_5">.gitignore</h3>

<pre><code># fastlane specific
fastlane/report.xml

# deliver temporary files
fastlane/Preview.html

# snapshot generated screenshots
fastlane/screenshots

# scan temporary files
fastlane/test_output
</code></pre>

<h3 id="toc_6">小感悟</h3>

<p>在lane中执行 通常terminal的命令是不ok，<br/>
需要使用 sh &quot;命令&quot;  执行才可以</p>

<h2 id="toc_7">Fastfile配置文件</h2>

<p><a href="https://github.com/DroidDreamer/codeDaily/blob/master/files/Fastfile">demo地址</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最大值连续子序列]]></title>
    <link href="iginkgo.cn/15325305399890.html"/>
    <updated>2018-07-25T22:55:39+08:00</updated>
    <id>iginkgo.cn/15325305399890.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<p>晚上在听得到的上吴军老师讲的《谷歌方法论的专栏》，题目叫做股票的最长增长期。其实也就是求的最大和的子序列方法。</p>

<blockquote>
<p>题目: 对于一个数组，数组内数值可正可负， 求其中和最大的子序列(不考虑空数组的情况)</p>
</blockquote>

<p>例如 [1,3,-2,-5,8,2,-3,6,-2]， 其和最大的子序列为 [8,2,-3,6].</p>

<pre><code>//swift代码
var list = [1,3,-2,-5,8,2,-3,6,-2]
//
</code></pre>

<p>当然，直接拿到这个题目，除了常规上的上来就做之外，还要考虑一下题目是否完整，以及各种边界情况，<br/>
比如<br/>
1.子序列的和溢出的情况<br/>
2.给出的数组为空的情况<br/>
文章中的方法并不会对这些情况作出处理， 但是在自己实现的过程中，一定要考虑到这些可能性。</p>

<h2 id="toc_0">专栏中的解法</h2>

<p>专栏中讲到四种方法，分别实现一下。</p>

<h3 id="toc_1">第一种，暴力遍历所有情况</h3>

<h3 id="toc_2">第二种，优化一些的算法</h3>

<h3 id="toc_3">第三种，分治算法</h3>

<h3 id="toc_4">第四种</h3>

<h2 id="toc_5">个人解法</h2>

<p>首先构建一个新的数组sum[], 其中存储的每个元素sum[i] = a[0]+ a[1] +..a[i],<br/>
也就是 sum[0] = a[0], sum[i] = sum[i-1] + a[i]</p>

<pre><code>var sum: [Int] = []
var count: Int = 0
for i in (0..&lt;list.size) {
  if i == 0 {
   sum.append(a[0])
   }else {
     sum.append(sum[i-1] + a[i])
   }
  count += list[i]
  sum.append(count)
}

</code></pre>

<p>然后最大子序列的问题，也就变成了数组sum中，差最大的两个值的问题。<br/>
若最大子序列为 a[left]... a[right], 则 sum[right]与sum[left-1]的差值也是最大的。</p>

<p>因此需要求sum数组中差值最大的情况。当然，要求下标 right &gt; left</p>

<pre><code>var minValue: Int = Int.max
var minValueIndex: Int = 0

var max: Int = Int.min
var left: Int = 0
var right: Int = 0

sum.enmurated.foreach{ (index, value) in
   if minValue &gt; value {
    minValue = value
    minValueIndex = index
   }
   
   let separatedValue = value - minValue
    if separatedValue  &gt; max {
        max = separatedValue
        right = index
        if left != minValueIndex {
          left = minValueIndex
        }
   }
}

//最终， sum[left...right] 会是其结果，其子序列的和为max




</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对于首页的优化]]></title>
    <link href="iginkgo.cn/15324828408733.html"/>
    <updated>2018-07-25T09:40:40+08:00</updated>
    <id>iginkgo.cn/15324828408733.html</id>
    <content type="html"><![CDATA[
<!-- 进行中 -->

<p>当前页面中存在的问题</p>

<pre><code>switch model.style {
case .news: 
    let cell = tableView.dequeue(&quot;newsCell&quot;) //config
    //...配置
    return cell
case .video:
     let cell = tableView.dequeue(&quot;videosCell&quot;) //config
    //...配置
    return cell
case .pic:
     let cell = tableView.dequeue(&quot;picsCell&quot;) //config
    //...配置
    return cell
case .beauty:
     let cell = tableView.dequeue(&quot;beautyCell&quot;) //config
    //...配置
    return cell
case .bigImage:
     let cell = tableView.dequeue(&quot;bigImageCell&quot;) //config
    //...配置
    return cell
default: ...
}
</code></pre>

<p>实际页面涉及到的cell种类不止这些，并且在未来的开发过程中会随着app特性的增加而增长，因为每次需要维护和更新时对整个大的代码块进行修改就编程一个非常杂乱的过程，稍有不慎还会影响整体的逻辑。那这里我们需要利用协议的特性进行设计。<a href="https://xiaozhuanlan.com/topic/2537681490">相关参考</a></p>

<p>实际项目中定义了一个协议，用来表示整个的数据类型</p>

<pre><code class="language-表示我们的基本类型以及转换后的类型">protocol ParseMessageType{
    associatetype: Original
    associatetype: ParseResult
}
</code></pre>

<p>那<code>Original</code>-&gt;<code>ParseResult</code>的转换步骤通过一个 parser来完成， 叫做<code>MessageParser</code></p>

<pre><code>protocol MessageParser {
 
 associatetype: Message
 associatetype: Target: ParaseMessageType where Message == Target.Original
    func parse(messgae: Message)-&gt; Target.ParsedResult
}

</code></pre>

<p>对于Target遵守 ParaseMessageType 的协议， 并且它的 original和message一致， 这就对parse方法的返回值进行了限定，编译过程中进行类型检查时会进行严格的类型匹配。</p>

<p>在具体MessageType实现的过程中</p>

<pre><code>final class ParsedChatMessage: ParsedMessageType {
    let output: NSAttributedString
    let original: ChatMessage
    
    init(message: ChatMessage){
        original = messgae
        let parser = Parser()
        self.output = parser.parse(message: message)
    }
}

struct Parser: MessageParser {
    typealias Target = ParsedChatMessage
    func parse(message: ChatMeaasge)-&gt; NSAttributeString {
     let reuslt = ...
     return .init(attributedString: result...)
    }
}


</code></pre>

<p>那么实际中的本地效果呢：</p>

<p>FeedModel   IndexProtocol   cellViewModel1  cellViewModel2cellViewModel3</p>

<p>在 feedModel，<br/>
在feedModel中实现fakeModel<br/>
FeedModel-&gt; IndexProtocol<br/>
fakeModel-&gt; IndexProtocol<br/>
TopicModel -&gt; IndexProtocol</p>

<p>对应的不同的cell， </p>

<p>此外，需要进一步实践的</p>

<p><a href="http://xiaozhuanlan.com/topic/6104325798">delegate改进</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[首页的优化记录]]></title>
    <link href="iginkgo.cn/15324314483651.html"/>
    <updated>2018-07-24T19:24:08+08:00</updated>
    <id>iginkgo.cn/15324314483651.html</id>
    <content type="html"><![CDATA[
<p>记录一个复杂页面的优化过程</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">第一次优化</h2>

<h3 id="toc_1">当前现状</h3>

<p>当前的页面有三个文件</p>

<pre><code>viewController.swift //处理交互和主体逻辑
viewController.xib   //当前页面的主要view 
viewModel.swift      //当前页面的主要网络请求、数据转换与存储、信号
</code></pre>

<p>当前的viewController是一个非常典型的<strong>“Massive view Controller”</strong>.<br/>
整个viewConttroller 大概1000行代码。</p>

<p>大体梳理一下具体的实现：</p>

<ol>
<li><p>初始化方法<br/>
普通view的初始化    10<br/>
tableView初始化    45<br/>
网络请求（失败和成功的UI变化）            20<br/>
事件监听        60行</p></li>
<li><p>tableView中涉及到的cell有8种混杂，<br/>
使用代码(如下方代码)的方式进行解析</p></li>
</ol>

<pre><code>switch viewmodel.list[indexpath.row].style {
case .news: //...
case .video: //...
case .image:// ...
...
}
</code></pre>

<p>其中方法<code>cellForRowAtIndex</code>  90行<br/>
方法 <code>cellDidSelect</code>  65行</p>

<ol>
<li>tableView上某些cell包含UICollectionView，需要具体实现<code>UICollectionDataSource</code>、<code>UICollectionDataSource</code>实现   60行</li>
<li>tableView上具体点赞按钮、关注按钮、收藏按钮等需要具体使用回调来相应   90行</li>
<li>其余的辅助方法  大约200行左右。</li>
</ol>

<p>当前代码结构过于雍容，像《代码大全》，《代码简洁之道》等总结代码规范的书籍，通常建议一个文件不要超过200行，最多不要超过400行。一个1000行左右的文件已经让人读起来非常吃力，并且考虑到业务会经常修改的情况，清晰的脉络是非常必要的。</p>

<h3 id="toc_2">当前进行的操作</h3>

<ol>
<li>将各种涉及到cell idendifier，cell height等跟固定的cell相关的一些常量，全部提取到cell本身代码中去。</li>
<li>去除整个页面中的魔幻数（突然出现的字符串、常量等），用一个变量进行代替。</li>
<li>创建一个<code>TableViewDataSource： NSObject, UITableViewDataSource</code>作为tableView的数据源。将对应的代码切换过去。</li>
</ol>

<h3 id="toc_3">遇到的问题</h3>

<p>在进行DataSource剥离的时候,出现tableView中高度失调的问题。</p>

<pre><code>//ViewController.swift
tableView.dataSource = TableViewDataSource()
tableView.delegate = self
</code></pre>

<pre><code>//UITableViewDataSource
public func numberOfSections(in tableView: UITableView)-&gt; Int
public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int
public func tableView(_ tableView: UITableView, cellForRow indexPath: IndexPath)-&gt; UITableViewCell
public func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat
</code></pre>

<p>调试许久发现，返回高度的方法<strong>不属于</strong><code>UITableViewDataSouce</code>.<br/>
问题的发生源于我的一个观念： DataSource通常是用于view在controller中获取所需数据、内容、view。 delegate是处理一些响应、监听的事件的。 但是从这次的问题来看，显然不是如此</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ObjectMapper学习]]></title>
    <link href="iginkgo.cn/15321858704283.html"/>
    <updated>2018-07-21T23:11:10+08:00</updated>
    <id>iginkgo.cn/15321858704283.html</id>
    <content type="html"><![CDATA[
<p>ObjectMapper<br/>
最近在写Mirror的时候，一直在考虑如何自动实现JSON 与Object之间的解析与赋值问题，而不需要手动进行key值的配置。因此对于当前Swift中常用的几个框架比较好奇。因此我打算解读一下 ObjectMapper是如何实现的。。</p>

<span id="more"></span><!-- more -->

<p>看一下ObjectMapper的结构</p>

<pre><code>Map.swift
Mapper.swift
Mappable.swift
MapError.swift

...Transform.swift


</code></pre>

<p>下面介绍一下主要的职能部分</p>

<h3 id="toc_0">Mapper</h3>

<p>Mapper是一个操作类，用于操作本地赋予的各种数值，list, dictionary等不同的类型，将类型统一后 生成对应的Map进行赋值操作。<br/>
它是控制整个转换操作过程中最大的操作类。</p>

<p>//TODO: 需要画图进行演示。</p>

<h4 id="toc_1">主要方法</h4>

<p>方法列表中的方法主要是兼容可能出现的各种输入形式，并最终分析目标类型的元素或者list， dictionary等。</p>

<pre><code>//class Mapper&lt;N: BaseMappable&gt;
//泛型N表示目标类型
public func map(JSONObject: Any?, toObject object: N) -&gt; N
public func map(JSONString: String, toObject object: N) -&gt; N
public func map(JSON: [String : Any], toObject object: N) -&gt; N
public func map(JSONString: String) -&gt; N?
public func map(JSONObject: Any?) -&gt; N?
public func map(JSON: [String : Any]) -&gt; N?
public func mapArray(JSONString: String) -&gt; [N]?
public func mapArray(JSONObject: Any?) -&gt; [N]?
public func mapArray(JSONArray: [[String : Any]]) -&gt; [N]
public func mapDictionary(JSONString: String) -&gt; [String : N]?
public func mapDictionary(JSONObject: Any?) -&gt; [String : N]?
public func mapDictionary(JSON: [String : [String : Any]]) -&gt; [String : N]?
public func mapDictionary(JSONObject: Any?, toDictionary dictionary: [String : N]) -&gt; [String : N]
public func mapDictionary(JSON: [String : [String : Any]], toDictionary dictionary: [String : N]) -&gt; [String : N]
public func mapDictionaryOfArrays(JSONObject: Any?) -&gt; [String : [N]]?
public func mapDictionaryOfArrays(JSON: [String : [[String : Any]]]) -&gt; [String : [N]]?
 public func mapArrayOfArrays(JSONObject: Any?) -&gt; [[N]]?
public static func parseJSONStringIntoDictionary(JSONString: String) -&gt; [String : Any]?
public static func parseJSONString(JSONString: String) -&gt; Any?
</code></pre>

<h3 id="toc_2">Map</h3>

<p>Map 提供一个基础的容器， 在获取JSON内容或者Object之后，提供一些基本的状态标识，数据存储</p>

<h4 id="toc_3">关键属性</h4>

<pre><code>public internal(set) var JSON: [String: Any] = [:] //存放要操作的json
public internal(set) var isKeyPresent = false// 当前key值对应的值是否存在
public internal(set) var currentValue: Any? //当前key值所对应的value值
public internal(set) var currentKey: String? //当前的key值
</code></pre>

<p>举了例子再进行说明<br/>
对于一个对象进行转化时，</p>

<pre><code>class Person: Mappable {
var age: Int?
var gender: String?
var height: Double?

func mapping(map: Map){
  age &lt;- map[&quot;age&quot;]
    gender &lt;- map[&quot;gender&quot;]
    height &lt;_ map[&quot;height&quot;]
}
}
</code></pre>

<p>调用方法</p>

<pre><code>Mapper&lt;Person&gt;().map(json: JSON) //生成对象
</code></pre>

<p>这边在进行转换的过程中，对于一个json，生成一个Map用于存储json并进行简单的数据操作。 在对于具体属性进行配给时，<br/>
具体的步骤<br/>
1. 处理<code>age &lt;- map[&quot;age&quot;]</code>时， 整个map的对象在map[“age”]的方法时， 调用下标方法， 设置 currentKey = “age”， currentValue = json[“age”], 由于要查找的key值在json中确实存在，isKeyPresent = true<br/>
2. 处理<code>gender&lt;-map[&quot;gender&quot;]</code>, 加入json这个字典中不存在json[“gender”],<br/>
则当前 <code>isKeyPresent=false</code>, currentValue = nil<br/>
3. 处理height值时，使用相同的逻辑进行处理</p>

<p>主要方法</p>

<pre><code>init(json: [String:Any],...) //进行json的赋值
subscript() //下标的方法，本身状态经过一定的修正，获取下标在json中对应的值，然后返回本身
func value&lt;T&gt;()-&gt; T? // 将subscripy中获取的值，判断是可转为用于需要的类型，并转换。

</code></pre>

<p>这个部分中的value方法是我非常感兴趣的地方。 因为整个Map文件只有这一个地方涉及到泛型的问题，而我好奇的是，泛型的类型是如何进行推断的。</p>

<pre><code>public func value&lt;T&gt;() -&gt; T? {
    let value = currentValue as? T 
  ...
    ... 
    ...
}
</code></pre>

<p>这个类型转换中，最终进行判断的类型是如何确定的呢？</p>

<p>让我们来看一下相关的调用方法：</p>

<pre><code>//Operator.swift
public func &lt;- &lt;T&gt;(left: inout T, right: Map) {
    switch right.mappingType {
    case .fromJSON where right.isKeyPresent:
        FromJSON.basicType(&amp;left, object: right.value()) //注意
    case .toJSON:
        left &gt;&gt;&gt; right
    default: ()
    }
}
</code></pre>

<pre><code>//FromJSON.swift
internal final class FromJSON {
    class func basicType&lt;FieldType&gt;(_ field: inout FieldType, object: FieldType?) {}
}
</code></pre>

<p>那让我们来梳理一下泛型T的推断过程</p>

<pre><code>func &lt;- &lt;T&gt;(left: inout T, right: Map)
func basicType&lt;FieldType&gt;(_ field: inout FieldType, object: FieldType?)
func value&lt;T&gt;()-&gt; T?
</code></pre>

<p>砰砰，划重点：<br/>
basicType方法声明了一个泛型，约束输入的两个参数属性应该是相同的。<br/>
而在Operator.swift中的方法，left这个参数类型 和 right.value()类型相同。<br/>
由于value()这个方法声明为一个泛型，这个类型是需要被推断出来的，因此最终确定是需要通过 left的属性来确定。<br/>
即： <strong>根据操作符</strong><code>&lt;-</code><strong>的做参数的属性来确定返回值的类型</strong><br/>
我认为这是类型推断非常强大的一点。</p>

<p>同样的, 我在playground上实验了类似的例子，说明编译器对于泛型中类型的推导具有延续性。<br/>
写一个泛型类型推导的例子<a href="https://github.com/DroidDreamer/codeDaily/blob/master/Generic%20type%20inference.playground/Contents.swift">泛型例子</a><br/>
//TODO: 此处添加类似的代码。Generic type inference</p>

<p>…Transform: 针对特定的类型设置转换规则</p>

<p>//TODO: 未完待续</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中的反射  Mirror (上) 认识和基本使用]]></title>
    <link href="iginkgo.cn/15321351019730.html"/>
    <updated>2018-07-21T09:05:01+08:00</updated>
    <id>iginkgo.cn/15321351019730.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">简介</h2>

<blockquote>
<p>Reflection: In computer science, reflection is the ability of a computer program to examine, introspect, and modify its own structure and behavior at runtime     --wikipedia</p>
</blockquote>

<!-- more -->

<p>在计算机科学中，反射指的是在计算机程序在运行时 检查，introspect， 修改自身结构以及行为的能力。</p>

<p><a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)">wikipedia介绍</a></p>

<p>在正常的iOS开发中，由于OC语言有着强大的运行时特性，它的能力要比反射高的多，因此在过去OC实现的iOS项目中并不多见。 Swift作为一个标准且强大的静态语言，本身并没有runtime的相关能力，只提供了<code>Mirror</code>来实现一些反射的特性。</p>

<h2 id="toc_1">Mirror基本介绍</h2>

<p><a href="https://developer.apple.com/documentation/swift/mirror">官方文档</a></p>

<h3 id="toc_2">表述：A representation of the substructure and display style of an instance of any type.</h3>

<p>对于一种类型内部结构的描述以及具体实例的展示类型</p>

<h3 id="toc_3">创建</h3>

<pre><code>class Car {
    var price: Int
    var color: String = &quot;red&quot;
    
    init(price: Int) {
        self.price = price
    }
}

let car = Car(price: 20000)
let mirror = Mirror(reflecting: car)
</code></pre>

<p>使用<code>Mirror</code>的<code>reflecting</code>方法，传出一个静态的实例， 获取该实例类型的反射结果</p>

<h3 id="toc_4">内部结构</h3>

<h4 id="toc_5">property</h4>

<pre><code>let children: Mirror.Children
A collection of Child elements describing the structure of the reflected subject.

var customMirror: Mirror
var description: String
let displayStyle: Mirror.DisplayStyle?
A suggested display style for the reflected subject.

let subjectType: Any.Type
The static type of the subject being reflected.

var superclassMirror: Mirror?
A mirror of the subject’s superclass, if one exists.

</code></pre>

<p>其中需要重点介绍的是 <code>Mirror.children</code></p>

<pre><code> typealias Mirror.Child = (label: String?, value: Any)
 typealias Mirror.Children = AnyCollection&lt;Mirror.Child&gt;
</code></pre>

<p>我们通常使用Mirror的反射来获取一个类型的内部变量，都是通过<code>Mirror.Child</code>来获取的。<br/>
 对于内部变量， <code>label</code>用于表述其内部参数名， <code>value</code> 表示其参数值。<br/>
 下面我们写一个例子，进行观察</p>

<p>示例</p>

<pre><code> for item in mirror.children {
    print(&quot;当前属性名为\(item.label), 属性的值为\(item.value)&quot;)
}
</code></pre>

<p>其输出结果为：<br/>
当前属性名为Optional(&quot;price&quot;), 属性的值为20000<br/>
当前属性名为Optional(&quot;color&quot;), 属性的值为red</p>

<p>当然，我们也看到，Mirror.child 作为一个 tuple，其第一个属性<code>label</code>是一个可选型。这是因为Mirror支持的类型很多，后面会进一步介绍， 对于一个 <code>Array</code> 进行反射，只会对属性值进行展示，却没有属性名， 这种情况下 属性名是会为空的。</p>

<h4 id="toc_6">descendant</h4>

<p>返回给定路径的对象，如果路径错误，则返回为nil。</p>

<pre><code>func descendant(MirrorPath, MirrorPath...) -&gt; Any?
Returns a specific descendant of the reflected subject, or nil if no such descendant exists.

protocol MirrorPath
A protocol for legitimate arguments to Mirror’s descendant method.
</code></pre>

<p>这个方法介绍给有多层类型嵌套的情况<br/>
例如，我们先重新修改 要检测的实例类型,在<code>Car</code>中嵌套一个class。</p>

<pre><code>class Driver {
    var gender: String = &quot;男&quot;
    var age: Int = 30
}

class Car {
    var price: Int
    var color: String = &quot;red&quot;
    var driver = Driver()
    
    init(price: Int) {
        self.price = price
    }
}

let car = Car(price: 20000)
let carMirror = Mirror(reflecting: car)
let mirror = Mirror(reflecting: car)
for item in mirror.children {
    print(&quot;当前属性名为\(item.label), 属性的值为\(item.value)&quot;)
}
</code></pre>

<p>实际情况是，对于 driver这个属性，无法进行清晰的表述<br/>
输出结果：<br/>
当前属性名为Optional(&quot;price&quot;), 属性的值为20000<br/>
当前属性名为Optional(&quot;color&quot;), 属性的值为red<br/>
当前属性名为Optional(&quot;driver&quot;), 属性的值为__lldb_expr_14.Driver</p>

<p>此时第三条driver，就是直接打印的driver的对象。<br/>
当然，如果需要对driver进行进一步输入，就要继续向下做下去了。</p>

<p><code>descendant</code> 这个方法可以返回给定路径的属性值。<br/>
例如：</p>

<pre><code>let gender = mirror.descendant(&quot;driver&quot;, &quot;gender&quot;)
print(gender)car
</code></pre>

<p>输出结构为 Optional(30)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[随想系列(-)]]></title>
    <link href="iginkgo.cn/15319270059690.html"/>
    <updated>2018-07-18T23:16:45+08:00</updated>
    <id>iginkgo.cn/15319270059690.html</id>
    <content type="html"><![CDATA[
<p>最近走上上班的路上，常常会触发一些联想。这可能就是乱七八糟的书多了，就会触发跨区域的传输。</p>

<p>今天思考了个问题， <strong>人为什么要学习呢？</strong><br/>
最近两天也在刷算法的一些问题。发现很多问题的解决确实是需要一些奇思妙想，这些天马行空的思想需要一个卓越的大脑来实现。然而大部分算法的实现都是有<strong>套路</strong>的。作为普通劳动力里的我，也就只能通过不断的接触和实践才能慢慢掌握。<br/>
这里就把解题的人分为两种类型：聪明人和平庸的人。 <br/>
针对一个问题，聪明人可能直接给出答案，平庸的人呢，要针对给出的细节，进行反复的思考。<br/>
这里就体现了不同的人，他的思维深度和广度。<br/>
思维的深度指的是，针对一个一些底层条件和细节，是否能够推断出高层次的结论，进而由这些高层次的结论，推断出想要的结果。 这个已知条件实现的“升级”，也就是我们平时常说的知识点了。对于不了解这些知识点的人，对于那些底层的细节，也都是束手无策的。<br/>
我又想到以前讨论的很火热的一个问题”现在搜索软件已经这么方便了，可以直接在网络搜索我需要的结果，那我还要花时间学习，有必要吗?“  我的结论是——非常有必要。<br/>
coursera上有一门课程，叫做《Learn How to learn》, 里面介绍了学习知识的一种理论： 我们学习的东西在大脑中就是一个点，与该知识相关的知识就是另外一个点，当我们学习并深化之后，两个点就会建立一个连接，在大脑思考问题时，考虑到某个点，就很自然的通过连接到达其他的相关知识点。这就是推论、联想。连接是可以通过不断的思考，练习来强化的。这样，随着点的越来越多，连接的越来越多，最终形成了牢固的知识体系。我们在考虑一个问题的时候，可以藉由这个知识网络到达体系内的任意一点。这也代表了在某一个领域内的广度和深度。而这一点是很难通过网络引擎来替代。<br/>
回到解题的问题上来，知识体系丰富的人，对于现有的条件，很容易在网络中寻找相关的信息，利用这些相关信息来处理问题。而体系狭窄，萎缩的人，想破脑袋也很难想的出来，临时使用搜索引擎，针对相关的知识进行学习，其挑选、吸收的过程就需要很大的成本。</p>

<p>我当前希望自己做的，就是不断强化和延伸这样的知识网络。</p>

<p>第二个想法呢， 每天做一件让自己赞叹的事情吧。让自己的一天显得与众不同。<br/>
第三个想法呢 克服习惯的惯性，克服欲望。完成一个完整的流程，好好的做完一件事。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WWDC 2018 Swift 4.2 新特性]]></title>
    <link href="iginkgo.cn/15282735197620.html"/>
    <updated>2018-06-06T16:25:19+08:00</updated>
    <id>iginkgo.cn/15282735197620.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<p><a href="https://devstreaming-cdn.apple.com/videos/wwdc/2018/401ieeclipzse3tz3fg/401/401_hd_whats_new_in_swift.mp4?dl=1">视频下载地址</a></p>

<ul>
<li>
<a href="#toc_0">优化</a>
</li>
<li>
<a href="#toc_1">在编译方便的优化</a>
<ul>
<li>
<a href="#toc_2">Compliation Mode</a>
</li>
<li>
<a href="#toc_3">Optimization Level</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">Swift语言特性</a>
<ul>
<li>
<a href="#toc_5">CaseIterable协议</a>
</li>
<li>
<a href="#toc_6">随机数生成以及打乱操作</a>
</li>
<li>
<a href="#toc_7">Enhanced conditional conformances</a>
<ul>
<li>
<a href="#toc_8">运行时的类型询问</a>
</li>
<li>
<a href="#toc_9">Optional、Array、Dictionary等对协议的默认实现</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_10">Hashable（未完待续）</a>
</li>
</ul>


<p>不得不赞叹一句 Xcode10下的playground运行起来真是比以前好到不行</p>

<h2 id="toc_0">优化</h2>

<p><code>TODO: 待补充</code></p>

<h2 id="toc_1">在编译方便的优化</h2>

<p><img src="media/15282735197620/1D720CC705576DB05D71C805EFE2BBB6.jpg" alt="1D720CC705576DB05D71C805EFE2BBB6"/></p>

<p>主要体现在两个方面</p>

<h3 id="toc_2">Compliation Mode</h3>

<p>在debug模式下建议开始<code>Incremental</code>模式，会大大提升效率<br/>
 <code>Whole Module</code>模式意味着在每次build会将全局进行build，耗时较长</p>

<h3 id="toc_3">Optimization Level</h3>

<p>其中有3个选项 <code>No optimization[-Onone]</code>,<code>Optimize for Speed [-O]</code>,<code>Optimize for Size[-Osize]</code><br/>
其中<code>Optimize for Size</code>模式是这次更新的一大主题<strong>Code Size</strong>的一部分，在开启之后， Code size可能会减少 10% - 30%， 但是运行时的特性可能会降低 5%。</p>

<h2 id="toc_4">Swift语言特性</h2>

<h3 id="toc_5">CaseIterable协议</h3>

<p>swift中的枚举类型在实现CaseIterable协议后，可以对每个case进行遍历操作。其具体操作如下</p>

<p><img src="media/15282735197620/F24356323AB18A4707FDC96E96D35FB8.jpg" alt="F24356323AB18A4707FDC96E96D35FB8"/></p>

<p>在上面的例子中，<code>FamilyMember</code> 这个枚举类型在实现CaseIterable协议之后， swift自动为其添加了静态变量</p>

<pre><code>static var allCase: [FamilyMember] {
    return  [.father, .mother, .brother, .sister]
}
</code></pre>

<p>但是需要注意的是，对于枚举类型中有关联变量的情况，系统不会自动实现allCase。</p>

<p>比如 下图中<code>case porsche(convertible: Bool)</code>涉及了关联变量。这种情况下，需要像图中的注释掉的代码那样自己生成 。</p>

<p><img src="media/15282735197620/4CC5806A78B51C75CA0789FB03A1D13D.jpg" alt="4CC5806A78B51C75CA0789FB03A1D13D"/></p>

<h3 id="toc_6">随机数生成以及打乱操作</h3>

<p>过去我们一般使用的随机数生成操作</p>

<pre><code>1+(arc4random() % 6) //生成1-6之间的随机数
</code></pre>

<p>swift4.2中提供的新的方法</p>

<pre><code>Int.random(in: 0..&lt;10)
Float.random(in: 0..&lt;1)
[&quot;1&quot;,&quot;he&quot;,&quot;she&quot;,&quot;we&quot;].randomElement()! //选举出一个随机的
[&quot;1&quot;,&quot;he&quot;,&quot;she&quot;,&quot;we&quot;].shuffled()   // 打乱顺序，重新组合
</code></pre>

<p>除了系统提供的随机数生成方法，我们也可以让系统调用我们自己写的随机数生成算法。<br/>
需要实现协议<code>RandomNumberGenerator</code></p>

<pre><code>struct PrivateRandom: RandomNumberGenerator {...} //定义自己的随机数生成方式
var pr = PrivateRandom()
Int.random(in: 0..&lt;10, using: &amp;pr) //按照自己的随机数生成方法进行生成
</code></pre>

<h3 id="toc_7">Enhanced conditional conformances</h3>

<p>conditional conformances 允许在只有在特定条件满足时，才实现某种协议</p>

<p>比如说</p>

<pre><code>
protocol Purchaseable {
    func buy()
}

struct Book: Purchaseable {
    func buy(){
     print(&quot;You bought a book&quot;)
    }
}

extension Array: Purchaseable where Element: Purchaseable {
    func buy(){
    
    }
}
</code></pre>

<h4 id="toc_8">运行时的类型询问</h4>

<p>但是如果在运行时 去询问这个array时，会出现crash的情况（因为默认把array定义为any）。<br/>
这个情况在Swift4.2中得到解决。</p>

<p>举例说明<br/>
<img src="media/15282735197620/F9E6BB62AB0D7F29BAEC7E1428ECD376.jpg" alt="F9E6BB62AB0D7F29BAEC7E1428ECD376"/></p>

<h4 id="toc_9">Optional、Array、Dictionary等对协议的默认实现</h4>

<p>在swift4.2之前，如果我们要对 两个容器是否相等进行判定，通常要手动实现Equatable协议。</p>

<p><img src="media/15282735197620/43EF202AEED4513984A2C30BDA907EAB.jpg" alt="43EF202AEED4513984A2C30BDA907EAB"/></p>

<p>在swift4.2中，对于这些容易类型， swift已经为我们做好了处理。</p>

<p><img src="media/15282735197620/A9F4B891E7C0A3D7C242ABE9838204AD.png" alt="A9F4B891E7C0A3D7C242ABE9838204AD"/></p>

<p><img src="media/15282735197620/170E2367105A5EB8FBBF90FF4D0184C6.png" alt="170E2367105A5EB8FBBF90FF4D0184"/></p>

<p><strong>未完待续</strong></p>

<h2 id="toc_10">Hashable（未完待续）</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[踩坑记录]]></title>
    <link href="iginkgo.cn/15282672319466.html"/>
    <updated>2018-06-06T14:40:31+08:00</updated>
    <id>iginkgo.cn/15282672319466.html</id>
    <content type="html"><![CDATA[
<!--more-->

<h3 id="toc_0">问题1  使用 Leaks检查项目内存泄漏，崩溃的问题</h3>

<p>问题描述</p>

<p>进入Leaks模拟器或者真机app，进入30s左右就出现崩溃的现象，但是正常运行app没有问题</p>

<p><a href="">参考资料</a><br/>
最后找到解决方案：<br/>
进入leaks之后，在开启任务前，<br/>
通过操作<code>file</code> -&gt; <code>recordOptions</code> -&gt; <code>recordCount</code> 取消选择</p>

<h3 id="toc_1">问题2 对于约束的判定</h3>

<p>应用场景： 一个superview 加入 一个子view-UITableView。<br/>
在后续需要找到tableView的顶部约束并改变其值，使之发生改变。</p>

<pre><code>  self.view.constraints.foreach { (const) in
    if const.firstAttribute == NSLayoutAttribute.top.
        let view = const.firstItem as? UITableView,
            view = self.tableView {
            //TODO: 此处已识别，do sth
            }
  }
</code></pre>

<p>在这对关系中 const中的item1是UITableView，item2是superView<br/>
由于tableView的位置需要通过 superView来进行确定。<br/>
在最初添加约束时， <code>superView.addConstraints(...)</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[代码观]]></title>
    <link href="iginkgo.cn/15209408940888.html"/>
    <updated>2018-03-13T19:34:54+08:00</updated>
    <id>iginkgo.cn/15209408940888.html</id>
    <content type="html"><![CDATA[
<p>即使觉得很平庸的现在，我也想在写代码的路上继续走下去。</p>

<span id="more"></span><!-- more -->

<p>最近写东西，常常拘泥于具体的实现、功能、以及在框架的基础之上可以实现的各种功能。对于框架不支持的东西，想当然的放弃、甚至没有想到过要去尝试思考一下如何去实现。好多东西觉得不会了，就完全是摸不到头脑，不知道什么情况，不知道怎么个定位了。<br/>
然而实际上，同一个体系/世界观下面的不同事物都是有关联的。在Coursera的课程《Learn how to learn》的课程中，更是讲到学习要利用类似的概念，首先确定一个“锚点”之后，每次的学习甚至知识的获取都要在前者的基础之上进行把控，这样不同的知识点之间就会建立“连接”、“突触”，知识点也会通过稳固的“连接”到达有关联的知识点的位置，大量的连接之后就会形成一个知识的网络体系，最终经过强化形成知识块。<br/>
然而在我这里呢，连接大部分不同体系的 枢纽（计算机核心基本知识）这个枢纽点感觉建立的有些问题，在上层的分支上出现问题时，不同沿着主脉络 向核心枢纽来进行坐标的定位（对应到基本的计算机问题，当前这样的一个问题是一个什么样的问题？能否实现。）<br/>
借用《被讨厌的勇气中》介绍的 阿尔弗雷德 的理念，看待事情，是否可以跳出当前的圈子，从一个更大的圈子里来看待这个问题。一旦产生这样的想法，以前的很多视角就都会不一样了。</p>

<p>昨天 听 臧成威 讲 在代码的写作方面，关于术和道之间的关系。虽然听着有点悬，但实际来说还真是这么个事情。  大概的意思也就是一个本质和表象的问题。他的这个论点跟我要开的这个帖子的立意是很相近的。</p>

<p>然后突然有个感受是，老天其实是个很奇妙的东西。它可能在你有些灵感、想法的时候，会给你一些引发你共鸣的东西，加深你的这一灵感。  我之前也遇到过这类的事情，比如说在 预编译阶段的相关东西 这里，在我很感兴趣，刚刚开始深入之时，有个大牛写了篇类似的blog，引发了我深深的共鸣。觉得老天真是有意思。   然后，也就没有然后了，我也没有紧紧抓住那个感觉搞起来。<br/>
有灵感的时候，紧紧的捉住吧，毕竟这个世界上，最后能够引起你兴趣的事情并不多。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode提速]]></title>
    <link href="iginkgo.cn/15209408664766.html"/>
    <updated>2018-03-13T19:34:26+08:00</updated>
    <id>iginkgo.cn/15209408664766.html</id>
    <content type="html"><![CDATA[
<p>如何更加快速的使用Xcode</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">1.把DeriveData放在内存中</h2>

<p><a href="http://blog.csdn.net/qq_30513483/article/details/70600301">相关地址</a></p>

<p>相关思路<br/>
1. 配置ram，让ram开辟出一块内存专门供Xcode使用<br/>
2. 连接Xcode，让Xcode连接到我们开辟出的专属内存中</p>

<p>方案<br/>
1.创建<code>.sh</code>文件</p>

<pre><code>#!/bin/bash
RAMDISK=”ramdisk”
SIZE=1024         #size in MB for ramdisk.
diskutil erasevolume HFS+ $RAMDISK \
     `hdiutil attach -nomount ram://$[SIZE*2048]`
</code></pre>

<p>2.命令行中执行 <code>./ramdisk.sh</code>命令，执行该脚本</p>

<pre><code>//注意：如果出现`Permission denied`的情况，使用
chmod 777 aa.sh
</code></pre>

<p>3.发现 ./Volume/ 下出现了一个新的内存空间</p>

<p>4.Xcode-&gt;Preference-&gt;Locations-&gt;Location Tab中 <br/>
DeriveData 目录选定为 Custom，然后路径为 /Volumes/“ramdisk”/DeriveData</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode基本操作]]></title>
    <link href="iginkgo.cn/15209407678838.html"/>
    <updated>2018-03-13T19:32:47+08:00</updated>
    <id>iginkgo.cn/15209407678838.html</id>
    <content type="html"><![CDATA[
<p>Xcode的基本操作、快捷键、调试</p>

<span id="more"></span><!-- more -->

<p>注意：<a href="http://www.cocoachina.com/ios/20141225/10761.html">原地址在此</a>,下面部分纯粹为个人记忆摘抄。</p>

<ul>
<li>
<a href="#toc_0">偏好设置</a>
</li>
<li>
<a href="#toc_1">代码阅读(快捷键)</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_2">View Navigator</a>
</li>
<li>
<a href="#toc_3">View Editor Organization</a>
</li>
<li>
<a href="#toc_4">Focus Switch</a>
</li>
<li>
<a href="#toc_5">Symbol Jump</a>
</li>
<li>
<a href="#toc_6">Symbol Navigator</a>
</li>
<li>
<a href="#toc_7">Help</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_8">代码编辑</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_9">File | New</a>
</li>
<li>
<a href="#toc_10">Text Editing</a>
</li>
<li>
<a href="#toc_11">Eidtor Window/Tab Switch</a>
</li>
<li>
<a href="#toc_12">Code Folding</a>
</li>
<li>
<a href="#toc_13">Console &amp; Scheme</a>
</li>
<li>
<a href="#toc_14">Gutter &amp; Ribbon</a>
</li>
<li>
<a href="#toc_15">Auto Completion</a>
</li>
<li>
<a href="#toc_16">Find &amp; Replace</a>
</li>
<li>
<a href="#toc_17">辅助编辑（Assistant Editor）</a>
</li>
<li>
<a href="#toc_18">环境变量（Build Setting Macros）</a>
<ul>
<li>
<a href="#toc_19">（1）查看环境变量宏</a>
</li>
<li>
<a href="#toc_20">（2）Xcode5(Mac OS X 10.9)的部分环境变量</a>
</li>
<li>
<a href="#toc_21">（3）设置环境变量</a>
</li>
</ul>
</li>
<li>
<a href="#toc_22">运行调试</a>
</li>
<li>
<a href="#toc_23">Watch</a>
</li>
<li>
<a href="#toc_24">lldb调试命令：</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_25">参考</a>
</li>
</ul>


<p><img src="media/15209407678838/Xcode%E7%95%8C%E9%9D%A2.png" alt="Xcode界面"/></p>

<h2 id="toc_0">偏好设置</h2>

<p>通过“command+,”快捷键或”Xcode|Preferences”菜单呼出偏好设置。</p>

<p>（1）主题及字体（Preferences-&gt;Fonts &amp; Colors）</p>

<p>选中一种主题（theme），例如“Midnight”，然后shift选择Source Editor/Console中的所有项，点击Fonts设置字体。Xcode默认字体为menlo，可选Consolas、Monaco等其他等宽字体。</p>

<p>（2）文本编辑配置（Preferences-&gt;Text Editing）<br/>
<img src="media/15209407678838/Editing.png" alt="Editing"/></p>

<ul>
<li>Show Line Numbers：在gutter中显示行号。</li>
<li>Code folding ribbon：显示折叠ribbon。</li>
<li>Page guide at column：显示一行最多支持80个字符的提示分割线。
Indentation：</li>
</ul>

<p>Prefer indent using：Spaces（为保持一致的视觉呈现和行末注释对齐，建议使用空格）<br/>
Tab width：4 spaces（tabexpand，1个tab=4个空格）<br/>
Indent width：4 spaces（自动缩进步长=4个空格）<br/>
（3）SCM（Preferences-&gt;Source Control）</p>

<p>Enable Source Control：启用/禁用XCode自带Source Control Manager(SCM)。</p>

<p>（4）SDK/Simulator（Preferences-&gt;Downloads）</p>

<p>Downloads-&gt;Components：可下载SDK和Simulator。</p>

<p>（5）构建输出目录（Preferences-&gt;Locations-&gt;Locations）</p>

<ul>
<li>当选择为Default时，Derived Data的目录为~/Library/Developer/Xcode/DerivedData。</li>
<li>当选择为Relative时，Derived Data的目录为当前.xcodeproj所在的目录。</li>
<li>当选择为Custom时，Derived Data的目录需自定义。</li>
</ul>

<p>不建议使用绝对路径，因为写死之后，换环境或换平台，又要重新修改路径，建议使用相对路径（Relative）。</p>

<h2 id="toc_1">代码阅读(快捷键)</h2>

<h4 id="toc_2">View Navigator</h4>

<p>command+0：Show/Hide left tool panel</p>

<p>command+1-8：Project/Symbol/Find/Issue/Test/Debug/Breakpoint/Log Navigator</p>

<p>option+command+0：Show/Hide right tool panel</p>

<p>option+command+1/2：show the file/quick help inspector</p>

<h4 id="toc_3">View Editor Organization</h4>

<p>control+1：Show Related Items（例如Superclasses/Subclasses、Callers/Callees、Protocol Implementor/Implemented、Includes/Included By）。可输入实时搜索匹配。</p>

<p>control+2/3：Show Previous/Next History。可输入实时搜索匹配。</p>

<p>control+4：Show Top Level Items。</p>

<p>control+5：Show Group Files（当前文件夹内的所有文件）。可输入实时搜索匹配。</p>

<p>control+6：Show Document Items（当前文件的Symbols）。可输入实时搜索匹配。</p>

<p>可直接选中符号，然后“Navigate-&gt;Reveal in Symbol Navigator”，打开该接口的符号列表。</p>

<h4 id="toc_4">Focus Switch</h4>

<p>command+J：焦点切换（Move Focus），可配合鼠标和方向键。带‘+’的“Move focus to a new assistant editor”可以快速在辅助编辑窗口中打开头文件（<em>.h）/实现文件（</em>.m，*.mm）。</p>

<p>shift+command+J：在项目导航中定位当前文件（Reveal in Project Navigator）。</p>

<h4 id="toc_5">Symbol Jump</h4>

<p>control+command+↑/↓：切换头文件/实现文件（switch between a source file (.m,<em>.mm,</em>.cc) and the associated header file(.h)）。</p>

<p>shift+command+O：Open Quickly，可快速查找文件、符号。</p>

<p>command+点击Editor中选中的符号：跳转到符号定义（jump to definition）。</p>

<p>control+command+J：跳转到指定符号的定义处或实现处（Go to Declaration/Definition）。有时工程正在Loading、Indexing或Processing files时，“command+点击”无法响应，此时可试试control+command+J。</p>

<p>在Project Navigator中选中文件右键或通过菜单“File-&gt;Show in Finder”：在Finder中定位该文件。</p>

<h4 id="toc_6">Symbol Navigator</h4>

<p>command+点击Editor中选中的非单一层次定义符号：Show in Symbol Navigator:</p>

<p>filter0：底部输入符号（show symbols with matching name）= filter1 result+filter3 result</p>

<p>filter1：show only class and protocol symbols (hide other global symbol types)，包括project和system层次。</p>

<p>filter2：show only project-defined symbols，过滤显示当前工程中的符号。filter2的结果是filter1的子集，较常用。</p>

<p>filter3：show only containers(hide members)，过滤显示包含该单词的符号。</p>

<h4 id="toc_7">Help</h4>

<p>option+点按：查看选中符号的帮助提示（Quick Help for Selected Item）。</p>

<p>option+双击：打开选中符号的帮助文档。</p>

<h2 id="toc_8">代码编辑</h2>

<h4 id="toc_9">File | New</h4>

<p>control+command+N：File | New | Workspace</p>

<p>shift+command+N：File | New | Project</p>

<h4 id="toc_10">Text Editing</h4>

<p>command+[/]：向前/向后缩进</p>

<p>option+command+[/]：Move Line Up/Down</p>

<p>command+/：注释选中的代码</p>

<p>Parentheses/Brackets/Braces Matching：双击某个分隔符（如()、[]、{} 等），Xcode会选中匹配代码块。</p>

<h4 id="toc_11">Eidtor Window/Tab Switch</h4>

<p>command+shift+[/]：切换标签页</p>

<p>单指左右滑动（control+command+←/→）：在单标签页打开的多个文件间切换</p>

<h4 id="toc_12">Code Folding</h4>

<p>option+command+←/→：折叠当前代码块</p>

<p>option+shift+command+←/→：折叠该文件内所有代码块（方法/函数）</p>

<h4 id="toc_13">Console &amp; Scheme</h4>

<p>shift+command+Y：显示控制台（Show/Hide the debug area）</p>

<p>option+command+R：编辑配置（Edit Scheme）</p>

<h4 id="toc_14">Gutter &amp; Ribbon</h4>

<p><img src="media/15209407678838/Gutter-Ribbon.png" alt="Gutter-Ribbon"/></p>

<p>焦点列：灰色深度与代码嵌套深度相关，鼠标悬停可突出显示右侧相应代码块，鼠标单击可折叠右侧相应代码块（Code Folding）。</p>

<p>说明：从左到右，依次是“导航窗格（Navigator）-&gt;边列（Gutter）-&gt;焦点列（Focus</p>

<p>Ribbon）-&gt;代码编辑窗口（Standard Editor）”。</p>

<h4 id="toc_15">Auto Completion</h4>

<p>esc（command+.）：就当前输入上下文呼出/隐藏Auto</p>

<p>Completion提示：上下方向键在提示中选择选项，enter(return)选中，tab可一截一截匹配；tab可在各个占位符之间移动。</p>

<p>输入Objective-C对象及 ]，自动完成中缀符(infixnatation)包围。</p>

<h4 id="toc_16">Find &amp; Replace</h4>

<p>command+F：当前文件查找。</p>

<p>option+command+F：当前文件替换。</p>

<p>Find：可指定查找内容（Text/References/Definitions/Regular Expression）；<br/>
放大镜：下拉可查看最近查找历史；<br/>
In Project：查找范围（可指定Group）；<br/>
Text：匹配规则（可指定Containing，Matching，Starting with，Ending with）；<br/>
Case：是否区分大小写（可指定 Matching/Ignoring）。<br/>
shift+command+F（command+3）：全局查找。也可以在选择符号后，右键（control+点击）-&gt;Find Selected Text in workspace...</p>

<p>option+shift+command+F：全局替换。</p>

<p>Replace：逐个替换；<br/>
All：所有替换；<br/>
Done：替换完成。</p>

<h4 id="toc_17">辅助编辑（Assistant Editor）</h4>

<p>Assistant Editor有点类似VC中的Code Definition Window。</p>

<p>option+command+enter：打开Assistant Editor。</p>

<p>command+enter：关闭Assistant Editor。</p>

<p>使用快捷键进行切换或跳转动作时，若同时按下option可以在辅助编辑窗口中打开相应文件或符号（For optional navigation (Option-clicking or Option-choosing a file), opens the file in a new Assistant editor pane.）。若在辅助窗口中操作，则在主窗口（Standard Editor）中打开。</p>

<ul>
<li>option+点击Project Navigator中选中的文件：在辅助编辑窗口中打开选中文件。</li>
<li>option+command+点击Editor中选中的符号：在辅助编辑窗口中打开符号定义（jump to definition in assistant editor）。</li>
<li>option+control+command+↑/↓：在辅助窗口中打开对应的头文件（<em>.h）/实现文件（</em>.m,<em>.mm,</em>.cc）。
点击查看shift+command+O、shift+command+F（command+3）选中的文件或符号时，可同时按下option在辅助编辑窗口中打开。</li>
</ul>

<p>在control+1~6中打开选择结果时，均可同时按下option在辅助编辑窗口中打开。</p>

<p>若在按下option的同时按下shift通常会出现一个导航窗格，可选择在new window/tab/assistant-editor显示打开。</p>

<p>ForOption-Shift navigation (Option-Shift-click or Option-Shift-choose a file), Xcode displays a graphical navigation chooser showing the current layout. The chooserprompts you to open the file in anyopen editor pane in any window and tab, or to open the file in anew editor pane, window, or tab.</p>

<p>20140219220929453.png</p>

<h4 id="toc_18">环境变量（Build Setting Macros）</h4>

<h5 id="toc_19">（1）查看环境变量宏</h5>

<p>命令行进入HelloWorld工程目录，执行xcodebuild命令并带上“-showBuildSettings”参数：</p>

<p>$ xcodebuild -project HelloWorld.xcodeproj -target HelloWorld -configuration Debug -showBuildSettings &gt; xcodebuild_showBuildSettings.txt</p>

<p>则xcodebuild_showBuildSettings.txt中保存了Build settings for action build and target &quot;HelloWorld”，其中dump了所有的环境变量。</p>

<h5 id="toc_20">（2）Xcode5(Mac OS X 10.9)的部分环境变量</h5>

<p>约定1：~=当前账户的HOME目录，例如“/Users/faner”。</p>

<p>约定2：build构建基础路径：BUILD_PATH = ~/Library/Developer/Xcode/DerivedData/Build。可通过“File-&gt;Project Settings”查看Derived Data Location。</p>

<p>约定3：环境变量宏（Build Setting Macros）引用格式：${MACRO}，同Build Phases Run Script中的语法。</p>

<p>下面是摘选自xcodebuild_showBuildSettings.txt的部分常用环境变量。</p>

<p><strong>(a) ARCH &amp; PLATFORM &amp; SDK</strong><br/>
ARCHS = i386</p>

<p>CURRENT_ARCH = i386</p>

<p>PLATFORM_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform</p>

<p>PLATFORM_NAME = macosx</p>

<p>SDKROOT = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk</p>

<p>SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk</p>

<p>SDK_NAME = macosx10.9</p>

<p><strong>(b) PROJECT &amp; SOURCE</strong></p>

<p>PROJECT = HelloWorld</p>

<p>PROJECT_DIR =~/Projects/Learn Objective-C/HelloWorld</p>

<p>PROJECT_FILE_PATH =${PROJECT_DIR}/HelloWorld.xcodeproj</p>

<p>PROJECT_NAME = HelloWorld</p>

<p>SOURCE_ROOT =${PROJECT_DIR}</p>

<p>SRCROOT =${PROJECT_DIR}</p>

<p><strong>(c) BUILD &amp; CONFIGURATION</strong></p>

<p>BUILD_DIR =BUILD_PATH/Products</p>

<p>BUILD_ROOT =BUILD_PATH/Products</p>

<p>BUILT_PRODUCTS_DIR =BUILD_PATH/Products/Debug</p>

<p>CONFIGURATION = Debug</p>

<p>CONFIGURATION_BUILD_DIR =BUILD_PATH/Products/Debug</p>

<p>CONFIGURATION_TEMP_DIR =BUILD_PATH/Intermediates/HelloWorld.build/Debug</p>

<p><strong>(d) PRODUCT &amp; TARGET</strong></p>

<p>PRODUCT_NAME = HelloWorld</p>

<p>PRODUCT_TYPE = com.apple.product-type.tool// Project Template: Command Line Tool</p>

<p>TARGET_BUILD_DIR =BUILD_PATH/Products/Debug</p>

<p>TARGET_NAME = HelloWorld</p>

<h5 id="toc_21">（3）设置环境变量</h5>

<p>Product -&gt; Edit Scheme（option+command+R）-&gt;Arguments-&gt;Environment Variables中可以添加自定义环境变量（Name为名称，Value为值）。</p>

<h4 id="toc_22">运行调试</h4>

<p>（1）Console</p>

<p>shift+command+Y：显示控制台（Show/Hide the debug area）</p>

<p>shift + command + K：清除控制台（Clean）</p>

<p>（2）Build</p>

<p>Product -&gt; Edit Scheme（option+command+R）-&gt;Info-&gt;Build Configuration：选择生成版本（Debug or Release）</p>

<p>command + B：构建（Buid）</p>

<p>（3）Target</p>

<p>一个Target是指在一个Project中构建的一个产品，它包含了构建该产品的所有文件，以及如何构建该产品的配置。</p>

<p>一个定义好构建过程的Target成为一个Scheme，可在Scheme中定义Target的六种构建过程：Build/Run/Test/Profile/Analyze/Archive。</p>

<p>Product -&gt; Edit Scheme（option+command+R）-&gt;Manage Schemes可对Scheme的六种构建过程进行配置（可配置项包括Info、Arguments、Options）。</p>

<p>在Project Navigator中选中某个xcodeproj（例如QQ.xcodeproj），将进入Project Setting页面，可点击左侧图标show/hide project and targets list：</p>

<p>0012.png</p>

<p>点击targets项可分别设置各target的Build Settings；右击可对target进行delete。</p>

<p>（4）Issue &amp; Errors</p>

<p>编译错误（error）和警告（warning）过多时，只显示编译错误：</p>

<p>0013.png</p>

<p>点击底端的感叹号，即可只显示编译错误，忽略编译警告：</p>

<p>0014.png</p>

<p>（5）Run</p>

<p>command + R：运行（Run），可能会先编译。若按下control直接运行上次build的product（Run Without Building）。</p>

<p>command + .：停止运行（Stop）</p>

<p>（6）Breakpoint</p>

<p>command + \：当前行设置/取消断点；通过鼠标点击蓝色断点来启用/禁用当前行断点。</p>

<p>command + Y：全局激活或禁用所有的断点，激活进入调试模式（此时断点蓝色可见）。</p>

<p>边列（Gutter）中的断点/警告可右键呼出Reveal in Breakpoint/Issue Navigator。</p>

<p>trick：编辑断点（Edit Breakpoint）：</p>

<p>Condition：设置断点的触发条件，例如“i==3”（注意不能有空格）表示当i等于3时该断点才会被触发。<br/>
Ignore：设置断点需要被忽略多少次才会中断，若设置成5则表示第6次遇到该断点时才触发。<br/>
Action：设置断点触发时的动作，可以为Debugger Command、Log Message、Shell Command或Sound。<br/>
例如可设置以下Debugger Command：</p>

<p>（1）读取std::string sig的内存buffer值：mem read sig.c_str() -c sig.size()；</p>

<p>（2）打印NSData实例sig：po sig</p>

<p>（7）Debug</p>

<p>F6：下一步（Step Over），逐过程单步调试，不进入函数体。</p>

<p>(fn+)F7：进入（Step Into）函数体。可能与多媒体键有冲突，故需要fn辅助。</p>

<p>(fn+)F8：跳出（Step Out）函数体。可能与多媒体键有冲突，例如呼叫iTunes，故需要fn辅助。</p>

<p>control+command+Y：逐断点（continue）继续执行。</p>

<p>trick：移动指令指针（Move the instruction pointer）：</p>

<p>0015.png</p>

<p>断点调试运行时，可以将绿色指针箭头（Line 47）移动到其他行（Line 49）或其他断点（Line 51）实现跳转执行。</p>

<h4 id="toc_23">Watch</h4>

<p>shift+command+M：Debug Workflow-&gt;View Memory。</p>

<p>command+K：Debug Workflow-&gt;Clear Console。</p>

<p>Debug Workflow-&gt;ShowDisassembly When Debugging，可进行汇编指令级调试。</p>

<p>trick：修改变量内存值（change memory value while debugging）：</p>

<p>调试运行时，可以在底部的调试窗口（Debug Area，可通过Shift+Command+Y呼出）右键某个变量，除了可以进行View Memory/View Value As之外，还可以选择Edit Value运行时编辑内存变量的值。</p>

<p>这种手动设置指定值，在调试某些难以复现的bug或进行边界测试非常有用，可以避免在验证某个问题时反复改值重新编译。</p>

<h4 id="toc_24">lldb调试命令：</h4>

<p>n/next：step over；<br/>
s/step：step into；<br/>
finish：step out；<br/>
c/continue：goto next breakpoint；<br/>
expr/expression：Evaluate a C/ObjC/C++ expression（动态执行C/ObjC/C++表达式）；<br/>
p/print/expr/expression：print as a C/C++ basic variable；<br/>
po/expr -O/expression -O：Print as an Objective-C object；<br/>
call：调用。其实上述p/po后接表达式(expression)也有调用的功能，一般只在不需要显式输出，或是无返回值时使用call，用于动态调试插入调用代码。<br/>
    例如可以在viewDidLoad:里面设置断点，然后在程序中断的时候输入以下命令：</p>

<pre><code>  call [self.view setBackgroundColor:[UIColor redColor]]
</code></pre>

<p>继续运行程序，view的背景颜色将变成红色！</p>

<p>bt（backtrace），打印当前调用堆栈（crash堆栈），“bt all”可打印所有thread的堆栈（相当于command+6的Debug Session Navigation）。<br/>
image：可用于寻址，有多个组合命令，比较实用的一种用法是寻找栈地址对应的代码（行）位置。<br/>
例如某个UITableView总共有2个section，当其引用的currentSection.index≥2时将会引起[UITableView rectForHeaderInSection:]调用异常，可使用expr动态改值制造crash场景模拟调试。</p>

<p>此时crash时的控制台bt显示异常出现在应用层代码“0x00d055b8 - [FACategoryTableView FACategorySectionHeaderDidTouched:] + 744”处（其中0x00d055b8为当前栈(代码段)偏移量，744为栈帧偏移量——PC指针相对函数入口的偏移）。</p>

<p>那么具体是FACategoryTableView.m文件哪一行代码调用引起的异常呢？此时通过“image lookup --address”后接bt的call stack中的代码段偏移地址（0x00d055b8）即可定位出异常调用的代码行位置。</p>

<p>x/memory read：dump指定地址的内存（Read from the memory of the process being debugged），后接起止地址或-c指定count加起始地址。可help mem read查看帮助：<br/>
Syntax:</p>

<pre><code> memory read[]
</code></pre>

<p>Command Options Usage:</p>

<pre><code>size指定内存块（block/item）的大小，默认为1byte。

--size)：The size in bytes to use when displaying with the selected format.
</code></pre>

<p>count指定内存块（block/item）的个数，可配合起始地址使用。</p>

<p>-c( --count)：The number of total items to display.</p>

<p>format指定内容显示格式，格式符同print：c-char，s-string，d-decimal，x-hex。</p>

<p>-f( --format)：Specify a format to be used for display.</p>

<p>Command Samples:</p>

<p>（a）起止地址</p>

<p>(lldb)mem read 0x10b88f0c 0x10b88f0c+9</p>

<pre><code>0x10b88f0c: 39 38 37 36 35 34 33 32 31                       987654321
</code></pre>

<p>（b）起始地址+内存块count</p>

<p>(lldb)mem read 0x10b88f0c -c 9</p>

<pre><code>0x10b88f0c: 39 38 37 36 35 34 33 32 31                       987654321
</code></pre>

<p>（c）起始地址+内存块size+内存块count（dump hex format）</p>

<p>(lldb)memory read -s 1 -f x -c 9 0x10b88f0c</p>

<p>0x10b88f0c: 0x39 0x38 0x37 0x36 0x35 0x34 0x33 0x32</p>

<p>0x10b88f14: 0x31</p>

<p>（d）起始地址+内存块size+内存块count（dump char format）</p>

<p>(lldb)memory read -s 1 -f c -c 9 0x10b88f0c</p>

<p>0x10b88f0c: 987654321</p>

<p>（e）起始地址+内存块size+内存块count（dump string format）</p>

<p>(lldb)mem read 0x10b5cf2c -f s -c 1</p>

<p>0x10b88f0c: &quot;987654321&quot;</p>

<p>（f）起始地址+内存块size+内存块count（dump int format）</p>

<p>(lldb)memory read -s 4 -f x -c 3 0x10b88f0c</p>

<p>0x10b88f0c: 0x36373839 0x32333435 0x109f0031</p>

<p>memory write：改写指定地址的内存（Write to the memory of the process being debugged）。可help mem write查看帮助：<br/>
   Syntax: memory write</p>

<p>[[...]]<br/>
（10）启用NSZombieEnabled调试EXC_BAD_ACCESS</p>

<p>当你对已释放的对象发送消息（90%的可能是对引用计数为0的对象再release）或release那些autorelease对象时，就会出现报EXC_BAD_ACCESS这样的错误。</p>

<p>默认设置下 Xcode不会给你定位具体是哪一行代码不该去使用已释放的对象，或者release用错了。</p>

<p>Product -&gt; Edit Scheme（option+command+R） -&gt; Diagnostics ，勾选“Objective-C”之后的“Enable Zombie Objects”。</p>

<p>设置NSZombieEnabled环境变量后，一个对象销毁时会被转化为_NSZombie；设置NSZombieEnabled后，当你向一个已经释放的对象发送消息，这个对象就不只是报EXC_BAD_ACCESS Crash，还会放出一个错误消息，然后以一种可预测的可以产生debug断点的方式消失， 因此我们可以找到具体或者大概是哪个对象被错误的释放或引用了。</p>

<p>注意：NSZombieEnabled只能在调试的时候使用，千万不要忘记在产品发布的时候去掉，因为NSZombieEnabled不会真正去释放dealloc对象的内存，一直开启后果自负！</p>

<h2 id="toc_25">参考</h2>

<p><a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/xcode_help-command_shortcuts/Introduction/Introduction.html">《Xcode Keyboard Shortcuts and Gestures》</a></p>

<p><a href="http://www.cocoachina.com/ios/20140225/7882.html">《Xcode Key Bindings &amp; Gestures》</a><br/>
<a href="http://www.cocoachina.com/industry/20140613/8816.html">《提升Xcode效率的小技巧》</a></p>

<p><a href="http://blog.csdn.net/shinancao666/article/details/13627979">《Xcode的文件组织》</a></p>

<p><a href="http://www.cnblogs.com/xiaodao/archive/2012/03/28/2422091.html">《Xcode环境变量及路径设置》</a><br/>
<a href="http://blog.csdn.net/fengsh998/article/details/8868871">《Xcode构建输出目录》</a></p>

<p><a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-basics.html">《LLDB Quick Start Guide》</a><br/>
<a href="http://lldb.llvm.org/lldb-gdb.html">《LLDB to GDB Command Map》</a><br/>
<a href="http://blog.163.com/jin_yuanwen/blog/static/19757915220131238104514">《Xcode gdb/lldb调试命令》</a></p>

<p><a href="http://blog.sina.com.cn/s/blog_6dce99b10101gwwo.html">《Xcode LLDB Debug教程》</a><a href="http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/">《LLDB调试命令初探》</a><a href="http://blog.csdn.net/cuiweijie3/article/details/8778198">《iOS应用崩溃日志揭秘》</a><a href="http://www.cnblogs.com/alario/archive/2012/03/27/2419710.html">《经营你的iOS应用日志》</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[viewController的生命周期]]></title>
    <link href="iginkgo.cn/15209406714961.html"/>
    <updated>2018-03-13T19:31:11+08:00</updated>
    <id>iginkgo.cn/15209406714961.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<p>在开发中遇到这样一个问题， viewControllerA向viewControllerB进行切换时，我需要在离开viewControllerA时，关闭全局控制器managerPlayer， 然后进入viewControllerB后，再次开启。返回之后继续进行使用managerPlayer进行视频播放。</p>

<p>因此我需要在 viewWillAppear()<br/>
           viewWillDisapper()进行设定。</p>

<p>突发好奇，我想整理一下，两个viewController进行切换时，其生命周期的调用情况，以及两者的生命周期在调用时的对应关系。</p>

<p>先发一下打印信息</p>

<pre><code>viewControllerA  viewDidLoad()
viewControllerA  viewWillAppear()
viewControllerA  viewWillLayoutSubviews()
viewControllerA  viewDidLayoutSubviews()
viewControllerA  viewDidAppear()

此处点击进行controller切换

viewControllerB  viewDidLoad()
viewControllerA  viewWillDisappear()
viewControllerB  viewWillAppear()
viewControllerB  viewWillLayoutSubViews()
viewControllerB  viewDidLayoutSubviews()
viewControllerA  viewDidDisappear()
viewControllerB  viewDidAppear()

</code></pre>

<p>然后考虑一下对于一个viewController中完整的生命周期</p>

<p><img src="media/15209406714961/life.png" alt="life"/></p>

<p>对于整个生命周期的方法进行总结</p>

<p><code>init</code> 进行整体的初始化<br/>
<code>loadView</code> 对于页面中的view进行了初始化,之后可以获取self.view的实例<br/>
<code>viewDidLoad</code>此时可以获取view以及其子类view，但是superView还没有。<br/>
<code>viewWillAppear</code> view即将显示的节点。每次显示该页面之前都会进入该时间节点   这里的尺寸已经都是实际的了么？<br/>
<code>viewDidAppear</code> view已经显示。（被加到另外一个view中）</p>

<p><code>viewWillDisappear</code> view即将消失 此时还没有调用 removeFromSuperView<br/>
<code>viewDidDisappear</code> view已经从superView中移除<br/>
<code>viewDidUnload</code> 干啥？</p>

<p>viewController主要负责的职能：<br/>
1. 该努力内部view的加载、显示、卸载<br/>
2. 负责与其他viewController的通信和协调</p>

<p>注意：</p>

<blockquote>
<p>Note: When overriding the loadView method to create your views programmatically, you should not call super. Doing so initiates the default view-loading behavior and usually just wastes CPU cycles. Your own implementation of the loadView method should do all the work that is needed to create a root view and subviews for your view controller.</p>

<p>注意： 如果需要重写loadView方法来创建你的view时，在loadView方法中不应该调用super，如果调用该方法的话可能会影响CPU性能。</p>
</blockquote>

<p>loadView与viewDidload的区别是 ，loadView时view还没有生成， viewDidLoad时，view已经生成了。loadView只会被调用一次，但是viewDidLoad可能会被调用多次（view可能多次加载），当view被添加到其他view中之前，会调用viewWillAppear。 当view不再使用时，收到内存警告时，viewController会将view释放并将其指向为nil。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tools]]></title>
    <link href="iginkgo.cn/15209405889264.html"/>
    <updated>2018-03-13T19:29:48+08:00</updated>
    <id>iginkgo.cn/15209405889264.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">code</h2>

<p><a href="http://asciiflow.com/">使用注释画图</a><br/>
<a href="https://www.processon.com/login">绘制流程图</a><br/>
<a href="https://www.appsight.io/">Find SDKs &amp; services used by iOS mobile apps</a><br/>
<a href="https://aso100.com/">iOS app排名</a></p>

<h2 id="toc_1">life</h2>

<p><a href="http://ip.taobao.com/index.php">ip地址查询</a><br/>
<a href="http://app2.sfda.gov.cn/datasearchp/gzcxSearch.do?formRender=cx&amp;page=1">药监局查询正品</a><br/>
<a href="http://sswz.spb.gov.cn/">快递投诉</a><br/>
<a href="https://github.com/cn">中国资料数据库 github开源</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《被讨厌的勇气》]]></title>
    <link href="iginkgo.cn/15209404638621.html"/>
    <updated>2018-03-13T19:27:43+08:00</updated>
    <id>iginkgo.cn/15209404638621.html</id>
    <content type="html"><![CDATA[
<p>中文名《被讨厌的勇气》</p>

<span id="more"></span><!-- more -->

<p>大约花了3天的时间，25-30个番茄时钟的时间细细读完了日本作家岸建一郎的书《被讨厌的勇气》, 刷了一遍自己的认知。<br/>
<img src="https://img1.doubanio.com/lpic/s29237648.jpg" alt="被讨厌的勇气"/></p>

<p>全书大体是一个 “目的论”为核心的思想，提倡充分发挥自己的主观能动性、利他但是不以他人的期待为约束，不拘泥过去，不过度关注未来，活在当下。<br/>
现做一下大体的总结，第一次阅读比较粗陋，今后还会继续修缮。</p>

<p><img src="media/15209404638621/TheCourageToBeHated.png" alt="TheCourageToBeHated"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[selfControl list]]></title>
    <link href="iginkgo.cn/15209404077015.html"/>
    <updated>2018-03-13T19:26:47+08:00</updated>
    <id>iginkgo.cn/15209404077015.html</id>
    <content type="html"><![CDATA[
<p>如何进行个人与知识的自我筛查</p>

<span id="more"></span><!-- more -->

<ul>
<li>
<a href="#toc_0">题记</a>
</li>
<li>
<a href="#toc_1">无聊时的List</a>
</li>
<li>
<a href="#toc_2">看书时的List</a>
</li>
<li>
<a href="#toc_3">揣摩问题/掌握一个问题要做的List</a>
</li>
</ul>


<h2 id="toc_0">题记</h2>

<p>这是自己从各种书籍看到、总结的，让自己在遇到/死磕/解决一个问题的时候需要顺序过滤一遍，让自己变的更好的事项清单。</p>

<h2 id="toc_1">无聊时的List</h2>

<p>最近学到过什么<br/>
锻炼</p>

<h2 id="toc_2">看书时的List</h2>

<p>1.问题<br/>
2.方案<br/>
3.例子</p>

<p>或者是<br/>
1.现象<br/>
2.解释<br/>
3.支撑该解释的理由<br/>
4.例子</p>

<h2 id="toc_3">揣摩问题/掌握一个问题要做的List</h2>

<ul>
<li>为什么是这样（为什么这样是好的）？</li>
<li>为什么不是那样（有其他做法吗/有更好的做法吗）？</li>
<li>这么做是最好的吗（为什么/能证明吗）？</li>
<li>这个做法与其他的做法有什么本质联系吗？</li>
<li>这个跟那个的区别是什么？</li>
<li>问题的本质是什么？</li>
<li>这个做法的本质有事什么？</li>
<li>到底本质上是什么东西导致了这个做法如此**？</li>
<li>与这个问题类似的还有其他问题吗？</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Macros_2]]></title>
    <link href="iginkgo.cn/15209403224294.html"/>
    <updated>2018-03-13T19:25:22+08:00</updated>
    <id>iginkgo.cn/15209403224294.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<p>宏的展开顺序</p>

<p>遇到宏名后(1)<br/><br/>
检查对应的宏体中是否含有#和##运算符<br/>
无——处理宏参数（实参）<br/>
    遇到宏名，回到(1)<br/>
    没有遇到，在宏体中用实参字符串替换形式参数，再检查是否遇到宏名(4)<br/>
 ...<br/>
有——不检查宏参数，在宏体中用实参字符串替换形式参数，再检查是否含有宏名(3)<br/>
    遇到宏名，回到(1)<br/>
    没有遇到，结束(5)</p>

<h2 id="toc_0">短路表达式</h2>

<p><a href="http://blog.163.com/m13591120447_1/blog/static/21637918920137811837285/">参考资料</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Macros_1]]></title>
    <link href="iginkgo.cn/15209402816526.html"/>
    <updated>2018-03-13T19:24:41+08:00</updated>
    <id>iginkgo.cn/15209402816526.html</id>
    <content type="html"><![CDATA[
<p>宏 第一部分</p>

<!--more-->

<h3 id="toc_0">宏的基本概念</h3>

<p>*注意：本文中讲述的宏以及相关例子都是在iOS环境下使用的。<br/>
百度定义</p>

<blockquote>
<p>一种批量处理的成为。它是一种规则或者模式，用于说明输入如何根据预定义的规则转换为对应的输出。</p>
</blockquote>

<p>WikiPedia定义</p>

<blockquote>
<p>一种批量处理的称谓。宏是一种抽象，根据一系列预定义的规则替换一定的文本。</p>
</blockquote>

<p>在我本人看来，宏是在<strong>预处理</strong>阶段，根据相应规则进行文本替换的一套机制。<br/>
&lt;!--more--&gt;</p>

<h3 id="toc_1">宏的基本用途</h3>

<ul>
<li>署名</li>
<li>宏展开</li>
<li>预编译判断</li>
</ul>

<p>宏的署名算是在OC编写iOS代码时，使用非常广泛的一种宏的应用了。可以用来定义一定的常量或者字符串，用于进行全局调用。</p>

<pre><code>#define M_PI  3.14159265358979323846264338327950288
</code></pre>

<p>宏展开的实例</p>

<pre><code>#define TRUE_AND_LOG(condition)         \
    do {                                \
        if(condition) {                 \
          NSLog(@&quot;your condition&#39;&quot;#condition&quot;&#39; is true&quot;);\
        }                               \
     }while(0)   
     

TRUE_AND_LOG(1 + 1 == 2);     
#最后会输出  “your condition 1 + 1 == 2 is true”
</code></pre>

<p>预编译判断的实例</p>

<pre><code>#静态判断   IF(判断条件)(为真时候的表达式)(为假时候的表达式)
#define IF(CONDITION) _CONCAT(_IF, CONDITION)
#define _CONSUME(...)  
#define _expand(...) __VA_ARGS__
#define _IF1(...) __VA_ARGS__ _CONSUME
#define _IF0(...) _EXPEND
</code></pre>

<p>本例实现的效果是，在判断条件为1(真)时，返回‘为真的表达式’。判断条件为0(假)时，返回<code>为假的表达式</code></p>

<h3 id="toc_2">宏中的基本符号</h3>

<ul>
<li><code>#</code></li>
<li><code>##</code></li>
<li><code>__FILE__</code> 和 <code>__LINE__</code> </li>
<li><code>...</code> 以及 <code>__VA_ARGS__</code></li>
<li><code>##__VA_ARGS__</code></li>
</ul>

<p>下面具体讲解一下各种符号的具体用法：</p>

<hr/>

<p><code>#</code>符号是用于把宏的参数字符串化。例如：</p>

<pre><code>#define NUMBER_ONE 1
#define STRINGFY(PARA)  # PARA

 STRINGFY(NUMBER_ONE)  //调用代码
 //结果  “NUMBER_ONE”
</code></pre>

<p>很多人质疑为何返回的结果不是 “1”，其实这与宏的展开方式有关系，详细请大家看 这二篇文章。</p>

<hr/>

<p><code>##</code>符号表示把左右两边的宏进行文本上的连接。</p>

<pre><code>#define DEF_VAR(type, name) type type##_##name

DEF_VAR(int， a) = 5
NSLog(@&quot;%d&quot;, int_a)

</code></pre>

<p>上述相当于 <code>int##_##a</code> 得到 <code>int_a</code>。</p>

<hr/>

<p><code>...</code>和<code>__VA_ARGS__</code><br/>
其中<code>...</code>用于在函数声明部分表示可变参数。它只会作为参数出现在小括号中。<br/>
<code>__VA_ARGS__</code>则用于函数的解释部分，同样表示 <code>...</code>所代表的可变参数<br/>
例如</p>

<pre><code>#define TOTO(NAME, ...)  NAME[__VA_ARGS__]
</code></pre>

<p><code>...</code>只能出现在函数的声明部分，<code>__VA_ARGS__</code>只能出现在右侧的解释部分。二者共同表示可变参数。</p>

<hr/>

<p>在OC语言环境下，有一些预定义好的默认宏，用于表示当前的环境</p>

<p><code>__FILE__</code> 表示当前代码所处的文件全路径 <br/>
<code>__LINE__</code> 表示当前代码所处的行号 <br/>
<code>__DATE__</code> 表示预编译时的日期<br/>
<code>__TIME__</code> 表示预编译时的时间<br/>
<code>__TIMESTAMP__</code> 预编译的时间戳<br/>
<code>__FUNCTION__</code> 当前函数</p>

<hr/>

<p><code>##__VA_ARGS__</code>用于可变参数个数为0时，去除前面的逗号<br/>
例如</p>

<pre><code>#define ABC(format, ...)    print(format, __VA_ARGS__);
</code></pre>

<p>如果上述可变参数个数为0时，则会出现<br/>
<code>ABC(&quot;%S&quot;)</code> -&gt; <code>print(&quot;%s&quot;,);</code>这样的情况，出现bug。<br/>
使用 <code>##__VA_ARGS__</code>可以去除前面的逗号，避免出现这个问题。</p>

<p><strong>文章粗陋，如有疏漏，希望可以联系笔者交流。</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Macros]]></title>
    <link href="iginkgo.cn/15209397332611.html"/>
    <updated>2018-03-13T19:15:33+08:00</updated>
    <id>iginkgo.cn/15209397332611.html</id>
    <content type="html"><![CDATA[
<p>在使用OC开发的项目中，宏是一个绕不开的话题。一个简单易用的宏库能够极大的提高生产力。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">介绍</h2>

<h3 id="toc_1">定义</h3>

<p>百度百科：</p>

<blockquote>
<p>一种批量处理的称谓。它是一种规则或者模式，用于说明 输入如何根据预定义的规则转换为对应的输出。</p>
</blockquote>

<p>Wikipedia</p>

<blockquote>
<p>一种批量处理的称谓。宏是一种抽象，根据一系列预定义的规则替换一定的文本模式。</p>
</blockquote>

<p>在港澳台又被称作 “巨集”</p>

<h3 id="toc_2">项目中的预定义宏</h3>

<h3 id="toc_3">基本示例</h3>

<p>项目中已有的，自定义的宏 都是一些比较基础的  比如</p>

<pre><code>#define DataManager ([SADataManager sharedManager])
#define SA_COLLECT_MODEL_CHANGED             @&quot;sa_collect_model&quot;
#define SA_COLLECT_NEWS_CHANGED              @&quot;sa_collect_news&quot;

</code></pre>

<h2 id="toc_4">操作符</h2>

<p>宏的高级语法(OC中用的不多)</p>

<ul>
<li>&quot;#&quot;</li>
<li>&quot;##&quot;</li>
<li>&quot;__FILE__&quot; 和  &quot;__LINE__&quot;</li>
<li>&quot;...&quot; 和 &quot;__VA_ARGS__&quot;</li>
<li>&quot;##__VA_ARGS&quot;</li>
</ul>

<p>1.<code>...</code>表示可变参数。如例子</p>

<pre><code>#define TOTO(NAME, ...)  NAME[__VA_ARGS__]
</code></pre>

<p>宏可以接受一个参数列表作为参数。这个参数列表具体的参数可能有很多。<br/>
在宏中，这个列表被定义为 <code>...</code> ， 这个参数列表在展开后 使用 <code>__VA_ARGS__</code>来表示。</p>

<p>2.<code>#</code> 符号表示 把宏的一个参数变为字符串(相当于生成一个带引号的字符串) <br/>
具体看下图示例：</p>

<pre><code>#define NUMBER_ONE 1
#define STRINGFY(A)  #A
    STRINGFY(NUMBER_ONE) #结果是 A   这个例子不对
</code></pre>

<p>3.<code>##</code>表示把前后两个宏进行字符串连接</p>

<pre><code>#define DEF_VAR(type, name)  type type##_##name
    
DEF_VAR(int, a) = 5
NSLog(@&quot;%d&quot;, int_a)     
</code></pre>

<pre><code>#define NAME_1  @&quot;William&quot;
#define NAME_2  @&quot;John&quot;
#define NAME_3  @&quot;Hugo&quot;

#define NAME_WITH(i)  NAME_##i

NSLog(@&quot;Name is %@&quot;, NAME_WITH(1));
</code></pre>

<pre><code>#define CONCAT(A, B)   A ## B
#define IS_EQ(A,B)   CONCAT(_IS_EQ, A)(B)
#define _IS_EQ1(B)   1
#define _IS_EQ2(B)   0
#define _IS_EQ3(B)   0 
</code></pre>

<pre><code>IS_EQ(2,3)  #=&gt;
_IS_EQ2(3)  #=&gt;
 #结果为2
</code></pre>

<p>4.<code>__FILE__</code>和<code>__LINE__</code><br/>
<code><br/>
__FILE__        文件全路径<br/>
__LINE__        行号   <br/>
__DATE__        预编译时的日期<br/>
__TIME__        预编译时的时间<br/>
__TIMESTAMP__   预编译日期和时间(时间戳)<br/>
__FUNCTION__    当前函数<br/>
</code><br/><br/>
其中，在swift中2.2之前会使用 <code>__FILE__</code> . <code>__LINE</code>. <code>__COLUMN__</code>.<code>__FUNCTION__</code>  在2.2之后被分别更换为<code>#file</code>,<code>#line</code>,<code>#column</code>,<code>#function</code> </p>

<p>5.<code>...</code>和<code>__VA_ARGS__</code><br/>
 <code>...</code>出现在宏定义的参数中，表示可变参数<br/>
 <code>__VA_ARGS__</code>则与之相对的，出现在宏的解释（实现）部分，用于表示参数中的可变参数。</p>

<p>6<code>##__VA_ARGS__</code> 表示在可变参数个数为0时，去除前面的逗号。</p>

<pre><code>#define ABC(format, ...) printf(format, __VA_ARGS__);
</code></pre>

<p>上述如果可变参数个数为0，则会出现<br/>
<code>ABC(&quot;%s&quot;)</code> -&gt; <code>printf(&quot;%s&quot;,);</code> <br/>
 使用 <code>##__VA_ARGS__</code> 可以有效的避免这个问题。</p>

<h2 id="toc_5">宏体现的三个重要的作用</h2>

<ul>
<li>署名</li>
<li>宏展开</li>
<li>预编译判断</li>
</ul>

<pre><code>#宏署名的例子
#define M_PI        3.14159265358979323846264338327950288
</code></pre>

<pre><code>#宏展开的例子1
#define TRUE_AND_LOG(condition)                                 \
    do {                                                        \
        if(condition) {                                         \
            NSLog(@&quot;your condition&#39;&quot;#condition&quot;&#39; is true&quot;);     \
        }                                                       \
    } while(0)
    
TRUE_AND_LOG(1 + 1 == 2);    
</code></pre>

<pre><code>#宏展开简化代码结构的例子2
#define TYPE_FLAG_LIST(_)                                       \
    _(TYPE_A)                                                   \
    _(TYPE_B)                                                   \
    _(TYPE_C)                                                   \
    _(TYPE_D)                                                   \
    _(TYPE_E)                                                   \
    _(TYPE_F)                                                   
    

#define ENUM_ELEMENT(FLAG)     FLAG,

typedef enum : NSUInteger {
        TYPE_FLAG_LIST(ENUM_ELEMENT)
        TYPE_TOTAL
} EnumTypeNum;
</code></pre>

<h4 id="toc_6">短路表达式与语法提示</h4>

<pre><code>#define KEY_PATH(CLASS, PATH)   \
    (((void)(NO &amp;&amp; ((void)[CLASS new].PATH, NO)), @# PATH))
</code></pre>

<pre><code>@implementation SomeClass 
+ (NSDictionary *)JSONKeyPathsByPropertyKey {
    return @{
     KEY_PATH(SomeClass, property1): @&quot;property_1&quot;,
     KEY_PATH(SomeClass, property2): @&quot;property_2&quot;,
     KEY_PATH(SomeClass, property3): @&quot;property_3&quot;,
    };
 }
</code></pre>

<p>上述单个公式展开后</p>

<pre><code>(((void)(NO &amp;&amp; ((void)[SomeClass new].property1, NO)), @&quot;property1&quot;)):@&quot;property_1&quot;
</code></pre>

<p>[class new].path是编译通过的。因而使用后续会出现语法提示。<br/>
<code>NO</code>和任意的布尔型进行判断， 肯定为空。 所以一般后面会屏蔽掉。</p>

<blockquote>
<p>逗号表达式：从左到右计算每一个表达式的值。<br/>
逗号运算符总表达式的值为最后一个数。</p>
</blockquote>

<p>整个方法的目的是：1.语法提示<br/>
               2.防止使用字符串的时候，输入错误。</p>

<p>预编译判断的例子</p>

<pre><code>#define ARG_AT(INDEX, ...) _ARG_AT##INDEX(__VA_ARGS__)

#define _ARG_AT0(_0, ...) _0
#define _ARG_AT1(_0, _1, ...) _1
#define _ARG_AT2(_0, _1, _2, ...) _2
#define _ARG_AT3(_0, _1, _2, _3, ...) _3
#define _ARG_AT4(_0, _1, _2, _3, _4, ...) _4
#define _ARG_AT5(_0, _1, _2, _3, _4, _5, ...) _5

int value = ARG_AT(3, 100, 200 ,300, 400)   #实际调用
</code></pre>

<pre><code>#静态判断   IF(判断条件)(为真时候的表达式)(为假时候的表达式)
#define IF(CONDITION) _CONCAT(_IF, CONDITION)
#define _CONSUME(...)  
#define _expand(...) __VA_ARGS__
#define _IF1(...) __VA_ARGS__ _CONSUME
#define _IF0(...) _EXPEND
</code></pre>

<p>宏 静态处理的缺陷：<br/>
 无法处理动态变量。<br/>
 举例：比如  处理 IF(a) 这样的情况，由于a是动态变量，在进行展开后得到 _IFa  然后就无法处理了。</p>

<h4 id="toc_7">c语言的预制宏(只能在OC中使用)</h4>

<h3 id="toc_8">对于Xcode，预处理或者预编译阶段是可以直接查看的</h3>

<p><img src="media/15209397332611/6D38A307046CC527055E9706C086E1E0.jpg" alt="6D38A307046CC527055E9706C086E1E0"/></p>

<p>注意：<br/>
1. 不同阶段的Preprocessed可能不同，要根据你的目标去选择预处理的条件。<br/>
2.宏经过预编译后出来的代码，可以检测宏写的是否正确，但是无法看到宏被展开的过程。 </p>

<h3 id="toc_9">ReactiveCocoa中的元宏（例子）</h3>

<p>作者定义了一些基础的宏，成为“元宏”，它们是构成之后复杂宏的基础。<br/>
1.metamacro_stringify(VALUE)</p>

<pre><code>#define metamacro_stringify(VALUE) \
        metamacro_stringify_(VALUE)
        
#define metamacro_stringify_(VALUE)    # VALUE
</code></pre>

<p>表示把宏的参数转换为字符串。</p>

<p>2.metamacro_concat(A,B)</p>

<pre><code>#define metamacro_concat(A,B)   \
        metamacro_concat_(A,B)
#define metamacro_concat_(A, B)  A ## B
</code></pre>

<p>合并A，B参数到一起。</p>

<p>3.metamacro_argcount(...)和 metamacro_at(N, ...)<br/>
获取参数个数                  获取参数第N个元素</p>

<pre><code>#define metamacro_argcount(...) \
        metamacro_at(20, __VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
</code></pre>

<p>注意：在预编译阶段处理，而非在运行时获取。</p>

<pre><code>#define metamacro_at(N, ...) \
        metamacro_concat(metamacro_at, N)(__VA_ARGS__)
</code></pre>

<p>继续展开，得到</p>

<pre><code>#define metamacro_at(N, ...) \
        metamacro_atN(__VA_ARGS__)
</code></pre>

<p>继续</p>

<pre><code>#define metamacro_at0(...) metamacro_head(__VA_ARGS__)
#define metamacro_at1(_0, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at2(_0, _1, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at3(_0, _1, _2, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at4(_0, _1, _2, _3, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at5(_0, _1, _2, _3, _4, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at6(_0, _1, _2, _3, _4, _5, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at7(_0, _1, _2, _3, _4, _5, _6, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at8(_0, _1, _2, _3, _4, _5, _6, _7, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at9(_0, _1, _2, _3, _4, _5, _6, _7, _8, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at10(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at11(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at12(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at13(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at14(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at15(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at16(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at17(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at18(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at19(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, ...) metamacro_head(__VA_ARGS__)
#define metamacro_at20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, ...) metamacro_head(__VA_ARGS__)

</code></pre>

<p>可见 N的取值只能从 0 到 20。</p>

<pre><code>#define metamacro_head(...) \
        metamacro_head_(__VA_ARGS__, 0)
#define metamacro_head_(FIRST, ...) FIRST
</code></pre>

<p>逻辑上来说，一个简单的变体如下</p>

<pre><code>define metamacro_head(FIRST, ..., 0)  FIRST
</code></pre>

<p>可知，这是用于获取后面可变入参的第一个参数。</p>

<p>对于 <strong>metamacro_at(N, ...)</strong></p>

<p>因而，<strong>metamacro_argcount(...)</strong></p>

<pre><code>#define metamacro_argcount(...) \
        metamacro_at20(__VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
</code></pre>

<ol>
<li>metamacro_head(...)</li>
</ol>

<pre><code>#define metamacro_head(...) \
        metamacro_head_(_VA_ARGS_, 0)
        
#define metamacro_head_(FIRST, ...) FIRST
</code></pre>

<p>作用：取出可变参数列表的第一个参数</p>

<ol>
<li>metamacro_tail(...)</li>
</ol>

<pre><code>#define metamacro_tail(...) \
        metamacro_tail_(__VA_ARGS__)
#define metamacro_tail_(FIRST, ...)  __VA_ARGS__
</code></pre>

<p>作用 取出可变参数列表除去第一个参数以外的所有参数。<br/>
限制条件： 可变参数中至少有两个参数。</p>

<ol>
<li><p>metamacro_take(N, ...)</p>

<pre><code>#define metamacro_take(N, ...)
        metamacro_concat(metamacro_take, N)(__VA_ARGS__) 
</code></pre>

<p>函数会展开为</p></li>
</ol>

<pre><code>    metamacro_takeN(__VA_ARGS__)
</code></pre>

<pre><code>#define metamacro_take0(...)
#define metamacro_take1(...) metamacro_head(__VA_ARGS__)
#define metamacro_take2(...) metamacro_head(__VA_ARGS__), metamacro_take1(metamacro_tail(__VA_ARGS__))
#define metamacro_take3(...) metamacro_head(__VA_ARGS__), metamacro_take2(metamacro_tail(__VA_ARGS__))
#define metamacro_take4(...) metamacro_head(__VA_ARGS__), metamacro_take3(metamacro_tail(__VA_ARGS__))
#define metamacro_take5(...) metamacro_head(__VA_ARGS__), metamacro_take4(metamacro_tail(__VA_ARGS__))
#define metamacro_take6(...) metamacro_head(__VA_ARGS__), metamacro_take5(metamacro_tail(__VA_ARGS__))
#define metamacro_take7(...) metamacro_head(__VA_ARGS__), metamacro_take6(metamacro_tail(__VA_ARGS__))
#define metamacro_take8(...) metamacro_head(__VA_ARGS__), metamacro_take7(metamacro_tail(__VA_ARGS__))
#define metamacro_take9(...) metamacro_head(__VA_ARGS__), metamacro_take8(metamacro_tail(__VA_ARGS__))
#define metamacro_take10(...) metamacro_head(__VA_ARGS__), metamacro_take9(metamacro_tail(__VA_ARGS__))
#define metamacro_take11(...) metamacro_head(__VA_ARGS__), metamacro_take10(metamacro_tail(__VA_ARGS__))
#define metamacro_take12(...) metamacro_head(__VA_ARGS__), metamacro_take11(metamacro_tail(__VA_ARGS__))
#define metamacro_take13(...) metamacro_head(__VA_ARGS__), metamacro_take12(metamacro_tail(__VA_ARGS__))
#define metamacro_take14(...) metamacro_head(__VA_ARGS__), metamacro_take13(metamacro_tail(__VA_ARGS__))
#define metamacro_take15(...) metamacro_head(__VA_ARGS__), metamacro_take14(metamacro_tail(__VA_ARGS__))
#define metamacro_take16(...) metamacro_head(__VA_ARGS__), metamacro_take15(metamacro_tail(__VA_ARGS__))
#define metamacro_take17(...) metamacro_head(__VA_ARGS__), metamacro_take16(metamacro_tail(__VA_ARGS__))
#define metamacro_take18(...) metamacro_head(__VA_ARGS__), metamacro_take17(metamacro_tail(__VA_ARGS__))
#define metamacro_take19(...) metamacro_head(__VA_ARGS__), metamacro_take18(metamacro_tail(__VA_ARGS__))
#define metamacro_take20(...) metamacro_head(__VA_ARGS__), metamacro_take19(metamacro_tail(__VA_ARGS__))
</code></pre>

<p>使用递归的思想，每次取完头之后，剩下的队列就是此次的tail。然后再递归取下次的head。</p>

<p>metamacro_take(N, ...)的作用就是取出可变参数的前N个数，并把它们组合成新的参数列表。</p>

<ol>
<li>metamacro_drop(N, ...)</li>
</ol>

<pre><code>#define metamacro_drop(N, ...)
        metamacro_concat(metamacro_drop, N)(__VA_ARGS__)
</code></pre>

<p>展开</p>

<pre><code>metamacro_dropN(__VA_ARGS__)
</code></pre>

<p>继续展开</p>

<pre><code>#define metamacro_drop0(...) __VA_ARGS__
#define metamacro_drop1(...) metamacro_tail(__VA_ARGS__)
#define metamacro_drop2(...) metamacro_drop1(metamacro_tail(__VA_ARGS__))
#define metamacro_drop3(...) metamacro_drop2(metamacro_tail(__VA_ARGS__))
#define metamacro_drop4(...) metamacro_drop3(metamacro_tail(__VA_ARGS__))
#define metamacro_drop5(...) metamacro_drop4(metamacro_tail(__VA_ARGS__))
#define metamacro_drop6(...) metamacro_drop5(metamacro_tail(__VA_ARGS__))
#define metamacro_drop7(...) metamacro_drop6(metamacro_tail(__VA_ARGS__))
#define metamacro_drop8(...) metamacro_drop7(metamacro_tail(__VA_ARGS__))
#define metamacro_drop9(...) metamacro_drop8(metamacro_tail(__VA_ARGS__))
#define metamacro_drop10(...) metamacro_drop9(metamacro_tail(__VA_ARGS__))
#define metamacro_drop11(...) metamacro_drop10(metamacro_tail(__VA_ARGS__))
#define metamacro_drop12(...) metamacro_drop11(metamacro_tail(__VA_ARGS__))
#define metamacro_drop13(...) metamacro_drop12(metamacro_tail(__VA_ARGS__))
#define metamacro_drop14(...) metamacro_drop13(metamacro_tail(__VA_ARGS__))
#define metamacro_drop15(...) metamacro_drop14(metamacro_tail(__VA_ARGS__))
#define metamacro_drop16(...) metamacro_drop15(metamacro_tail(__VA_ARGS__))
#define metamacro_drop17(...) metamacro_drop16(metamacro_tail(__VA_ARGS__))
#define metamacro_drop18(...) metamacro_drop17(metamacro_tail(__VA_ARGS__))
#define metamacro_drop19(...) metamacro_drop18(metamacro_tail(__VA_ARGS__))
#define metamacro_drop20(...) metamacro_drop19(metamacro_tail(__VA_ARGS__))
</code></pre>

<p><code>metamacro_drop(N, ...)</code>丢掉当前参数列表里的前N位参数</p>

<h1 id="toc_10">注意事项</h1>

<p>1.宏中常出现的do{ }while(0)；</p>

<p>2.对于出现的问题，通常很多方法  比如</p>

<pre><code>#define concat(A, B) concat_(A,B)
#define concat_(A,B)  A ## B
</code></pre>

<p>对于一个函数的调用，复合嵌套了一层， 有什么必要性？如果没有这一层会怎么样？<br/>
单纯的一个连接操作，非要加到concat函数里面，有什么必要性？如果没有concat函数，直接使用会怎么样？<br/>
3.</p>

<p>了解宏的必要性<br/>
1.工程配置中，会有一些 预编译宏 ，进行自己一些想要的设定<br/>
  不同的环境，不同的sdk(模拟器、真机)</p>

<h2 id="toc_11">这里仅需要进行测试</h2>

<p><img src="media/15209397332611/DD36A13FBBDA49DD999A253943A2EA99.jpg" alt="DD36A13FBBDA49DD999A253943A2EA99"/></p>

<p>宏的优缺点：</p>

<table>
<thead>
<tr>
<th style="text-align: center">优点</th>
<th style="text-align: center">缺点</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">不扩大二进制体积</td>
<td style="text-align: center">晦涩难懂</td>
</tr>
<tr>
<td style="text-align: center">不占用运行时</td>
<td style="text-align: center">功能严重受限</td>
</tr>
<tr>
<td style="text-align: center">代码简洁</td>
<td style="text-align: center">排错困难</td>
</tr>
<tr>
<td style="text-align: center">深入理解预处理过程</td>
<td style="text-align: center">其它语言几乎无法借鉴</td>
</tr>
</tbody>
</table>

<p>启发：<br/>
* 已用现有的能力拓展不存在的能力<br/>
* 受限的功能匹配受限的需求（比如说 个数受限 等等）<br/>
* 分段分析，推演的能力<br/>
* 冷知识 </p>

<h3 id="toc_12">参考目录</h3>

<p><a href="http://baike.baidu.com/link?url=GfcnklkqhXb6KzPVn-PnkzwM6hCkKXNoLWJbmGEsTiWJut57j7cZDeSW9FbzVjZyNY3tGsD0Qfv3kb59gQ-KkQpE4mY7gUSHT6RRLoYXQi7">百度百科</a><br/>
<a href="https://en.wikipedia.org/wiki/Fallacy">wikipedia</a><br/>
<a href="http://www.jianshu.com/p/4c5613e256c8">ReactiveCocoa 中 奇妙无比的“宏”魔法</a> 介绍了常用的基本例子<br/>
<a href="https://onevcat.com/2014/01/black-magic-in-macro/">宏定义的黑魔法 - 宏菜鸟起飞手册</a></p>

<h1 id="toc_13">老版本SohuAuto的例子</h1>

<p><img src="media/15209397332611/7B0EFF139D6668D04041DBFB997E3FD3.jpg" alt="7B0EFF139D6668D04041DBFB997E3FD3"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac下的常用命令]]></title>
    <link href="iginkgo.cn/15209393931542.html"/>
    <updated>2018-03-13T19:09:53+08:00</updated>
    <id>iginkgo.cn/15209393931542.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<p>打开/关闭 显示默认的隐藏文件<br/>
注意：命令执行后，须重新启动<code>finder</code></p>

<pre><code>//打开
defaults write com.apple.finder AppleShowAllFiles -bool true

//关闭
defaults write com.apple.finder AppleShowAllFiles -bool false
</code></pre>

]]></content>
  </entry>
  
</feed>
