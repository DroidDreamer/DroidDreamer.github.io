<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[iginkgo在路上]]></title>
  <link href="iginkgo.cn/atom.xml" rel="self"/>
  <link href="iginkgo.cn/"/>
  <updated>2018-09-05T16:44:36+08:00</updated>
  <id>iginkgo.cn/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[RxCocoa中的代码hook解析]]></title>
    <link href="iginkgo.cn/15361137574405.html"/>
    <updated>2018-09-05T10:15:57+08:00</updated>
    <id>iginkgo.cn/15361137574405.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<ul>
<li>
<a href="#toc_0">介绍</a>
</li>
<li>
<a href="#toc_1">Let&#39;s go</a>
</li>
<li>
<a href="#toc_2">MessageSentProxy</a>
</li>
<li>
<a href="#toc_3">registerMessageInterceptor(selector)</a>
</li>
<li>
<a href="#toc_4">解读方法的hook</a>
</li>
</ul>


<h2 id="toc_0">介绍</h2>

<p>在RxCocoa的代码中，对于<code>NSObject</code>的扩展中，有这两个代码，</p>

<pre><code>public func sentMessage(_ selector: Selector) -&gt; Observable&lt;[Any]&gt;
public func methodInvoked(_ selector: Selector) -&gt; Observable&lt;[Any]&gt;
</code></pre>

<p>他们分别实现的是在参数<code>selector</code>对应的方法执行前和执行后，分别发出信号，并可以使用RxSwift的监听模式进行监听。</p>

<p>下面是使用效果：</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

class ViewController: UIViewController {
    private let bag = DisposeBag()

    override func viewDidLoad() {
        self.rx.sentMessage(#selector(ViewController.viewWillAppear(_:))).asObservable().subscribe { (_) in
            print(&quot;sendMessage&quot;)
        }.disposed(by: bag)
        
        self.rx.methodInvoked(#selector(ViewController.viewWillAppear(_:))).asObservable().subscribe { (_) in
            print(&quot;methodInvoked&quot;)
        }.disposed(by: bag)
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        print(&quot;viewWillAppear&quot;)
    }
}
</code></pre>

<p>输出结果<br/>
<img src="media/15361137574405/15361338672279.jpg" alt=""/></p>

<p>最终的效果是在该方法的执行前与执行后的两个时间点进行了hook，插入了其他的方法。</p>

<p>下面我们就剖析一下，RxCocoa究竟做了些什么。<br/>
本文会从外部调用的方法<code>setMessage</code>开始，一步步查看内部的具体的实现。</p>

<h2 id="toc_1">Let&#39;s go</h2>

<p>简单剖析一下上面的代码，它们分别是对于两个Observable进行了监听(<a href="https://github.com/ReactiveX/RxSwift">RxSwift的介绍</a>)。换句话说，在实际的实现过程中，<br/>
selector对应的方法在即将执行前肯定是要触发setMessage所对应的Observable并发出信号。<br/>
selector对应的方法在执行完成肯定要触发methodInvoked所对应的Observable并发出信号。</p>

<p>当然，这都是我们基于当前的调用方法给出的推测，那看看实际都做了些什么。</p>

<p>首先看<code>setMessage</code>所对应的方法的具体实现。</p>

<pre><code>   public func sentMessage(_ selector: Selector) -&gt; Observable&lt;[Any]&gt; {
        return synchronized {
            // in case of dealloc selector replay subject behavior needs to be used
            if selector == deallocSelector {
                return deallocating.map { _ in [] }
            }

            do {
                let proxy: MessageSentProxy = try registerMessageInterceptor(selector) 
                return proxy.messageSent.asObservable()
            }
            catch let e {
                return Observable.error(e)
            }
        }
    }
</code></pre>

<p>上面的代码有2行是核心。</p>

<p><code>let proxy: MessageSentProxy = try registerMessageInterceptor(selector)</code><br/>
<code>proxy.messageSent.asObservable()</code> </p>

<p>其中第一行代码实现的功能是： 为该selector创建一个代理对象，如果已经有了，则直接返回<br/>
第二行代码，则是返回messageSent的信号源，它能保证在恰当的时候出发信号。</p>

<p>下面分别要对这两个代码进行具体的分析</p>

<h2 id="toc_2">MessageSentProxy</h2>

<p>贴一下MessageSentProxy的具体的代码</p>

<pre><code>fileprivate final class MessageSentProxy
        : MessageInterceptorSubject
        , RXMessageSentObserver {
        typealias E = [AnyObject]

        let messageSent = PublishSubject&lt;[Any]&gt;() //message所对应的subject（Observable），也就是被观察者
        let methodInvoked = PublishSubject&lt;[Any]&gt;()//invoked 所对应的被观察者

        @objc var targetImplementation: IMP = RX_default_target_implementation()

        var isActive: Bool {
            return targetImplementation != RX_default_target_implementation()
        }

        init() {
        }

        @objc func messageSent(withArguments arguments: [Any]) -&gt; Void {
            messageSent.on(.next(arguments))
        }

        @objc func methodInvoked(withArguments arguments: [Any]) -&gt; Void {
            methodInvoked.on(.next(arguments))
        }

        deinit {
            messageSent.on(.completed)
            methodInvoked.on(.completed)
        }
    }
</code></pre>

<p>从上面可以看出，<code>MessageSentProxy</code>这个类分别持有了名为<code>messageSent</code>以及<code>methodInvoked</code>的两个被观察者。<br/>
应该可以看出，他们分别对应着selector前后的触发时机，对这两个参数进行监听，也就是变相的监听了selector触发的前后的时机。</p>

<p>其中内部的<code>messageSent(withArguments arguments: [Any])</code>以及<code>methodInvoked(withArguments arguments: [Any])</code>方法分别促使两个被观察者发出信号。</p>

<p>两个方法分别用@objc进行修饰，标明两个方法都可以被OC的调用机制触发。</p>

<p>那当前可以整理出的触发顺序是：<br/>
1. MessageSentProxy中<code>messageSent(withArguments arguments: [Any])</code>发放被调用<br/>
2. MessageSentProxy中<code>messageSent = PublishSubject&lt;[Any]&gt;()</code>触发onNext信号<br/>
3. 外部对于<code>messageSent</code>的监听事件触发</p>

<p>那好，继续深究一下。</p>

<h2 id="toc_3">registerMessageInterceptor(selector)</h2>

<p>上面讲到<code>registerMessageInterceptor(selector)</code>方法是通过selector来创建一个MessageSentProxy，用来实现Observable。 由于同一个selector可能有2个监听事件<code>sentMessage</code>以及<code>methodInvoke</code>, 而两者都是通过同一个<code>MessageSentProxy</code>来实现。因此最终一个selector对应于一个MessageSentProxy,也不需要进行反复的创建。<br/>
那究竟做了哪些事情呢？</p>

<pre><code> //该方法保证了，在同一个target上 同一个selector 只会有 一个MessageInterceptorSubject与之绑定。
    fileprivate func registerMessageInterceptor&lt;T: MessageInterceptorSubject&gt;(_ selector: Selector) throws -&gt; T {
        let rxSelector = RX_selector(selector) //添加前缀，生成一个新的selector 当前只有名字
        let selectorReference = RX_reference_from_selector(rxSelector) 

        let subject: T
        if let existingSubject = objc_getAssociatedObject(base, selectorReference) as? T { //如果这个selector有关联值的话， 赋值给subject
            subject = existingSubject
        }
        else { //如果没有，则创建一个Subject对象，把它关联给当前的base
            subject = T()
            objc_setAssociatedObject(
                base,
                selectorReference,
                subject,
                .OBJC_ASSOCIATION_RETAIN_NONATOMIC
            )
        }

        if subject.isActive { // 表示其内部的IMP 其实已经赋值了， 否则就是还没有赋值。
            return subject
        }

        var error: NSError?
        let targetImplementation = RX_ensure_observing(base, selector, &amp;error)
        if targetImplementation == nil {
            throw error?.rxCocoaErrorForTarget(base) ?? RxCocoaError.unknown
        }

        subject.targetImplementation = targetImplementation!

        return subject
</code></pre>

<p>上面的代码做了大概几件事：<br/>
1.将MessageInterceptorSubject，也就是该方法调用处的MessageSentProxy通过selector与当前的对象进行绑定。</p>

<p>2.如果对应的selector已经绑定过了，则获取已绑定的MessageSentProxy。<br/>
这是由于对应同一个selector，我们可能有sentMessage以及methodInvoke两个监听事件，两个监听事件由于可以使用同一个MessageSentProxy，避免重复工作。<br/>
3.开始hook对应的selector，进行插入操作<br/>
核心代码<br/>
<code>let targetImplementation = RX_ensure_observing(base, selector, &amp;error)</code></p>

<h2 id="toc_4">解读方法的hook</h2>

<p>这也是当前这个过程中最核心的部分。<br/>
还记得KVO是怎么实现的吗？如果不记得，可以在看一下(<a href="15360544284777.html">KVO代码测试以及探究</a>)</p>

<p>继续向下深究<code>RX_ensure_observing(base, selector, &amp;error)</code>,并且删除用于行，留下核心代码</p>

<pre><code>/**
 This is the main entry point for observing messages sent to arbitrary objects.
 */
-(IMP __nullable)ensurePrepared:(id __nonnull)target forObserving:(SEL __nonnull)selector error:(NSErrorParam)error {
    Method instanceMethod = class_getInstanceMethod([target class], selector); //根据target sel 获取method

        Class __nullable swizzlingImplementorClass = [self prepareTargetClassForObserving:target error:error];
        if (swizzlingImplementorClass == nil) {
            return nil;
        }

        NSString *methodEncoding = RX_method_encoding(instanceMethod);
        RXInterceptWithOptimizedObserver optimizedIntercept = optimizedObserversByMethodEncoding[methodEncoding];

        if (!RX_method_has_supported_return_type(instanceMethod)) {
            RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
                                               code:RXObjCRuntimeErrorObservingMessagesWithUnsupportedReturnType
                                           userInfo:nil], nil);
        }

        // optimized interception method
        if (optimizedIntercept != nil) {
            IMP interceptorIMPForSelector = [self interceptorImplementationForSelector:selector forClass:swizzlingImplementorClass];
            if (interceptorIMPForSelector != nil) {
                return interceptorIMPForSelector;
            }

            if (!optimizedIntercept(self, swizzlingImplementorClass, selector, error)) {
                return nil;
            }

            interceptorIMPForSelector = [self interceptorImplementationForSelector:selector forClass:swizzlingImplementorClass];
            if (interceptorIMPForSelector != nil) {
                return interceptorIMPForSelector;
            }
        }
        // default fallback to observing by forwarding messages
        else {
            if ([self forwardingSelector:selector forClass:swizzlingImplementorClass]) {
                return RX_default_target_implementation();
            }

            if (![self observeByForwardingMessages:swizzlingImplementorClass
                                          selector:selector
                                            target:target
                                             error:error]) {
                return nil;
            }

            if ([self forwardingSelector:selector forClass:swizzlingImplementorClass]) {
                return RX_default_target_implementation();
            }
        }
    

    RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
                                       code:RXObjCRuntimeErrorUnknown
                                   userInfo:nil], nil);
}

</code></pre>

<p>那实际是如何fake出一个新的派生的class来取代原来的class呢？</p>

<pre><code>-(Class __nullable)prepareTargetClassForObserving:(id __nonnull)target error:(NSErrorParam)error
</code></pre>

<p>这个方法做了一下几件事<br/>
1.如果已经有了， 则直接返回（通过关联值进行关联）<br/>
2.如果class方法与object_getClass获取的元类型不一样，判断是否为KVO，若不是，默认无法处理，返回错误<br/>
3.生成最终的fakeClass， 并与关联类型进行绑定。</p>

<p>其中，这个fakeClass就类似于KVO机制中的<code>NSKVONotifying_类名</code>. 都是起到一个替换的作用，让实际方法执行的selector被重写，执行的起始以及结尾分别加入触发。</p>

<p>那说到底，还是没有说，具体这两个方法在细节上是如何插入对应的节点的(捂脸)。</p>

<p>有关于fakeClass的具体实现过程，我会在下一篇文章中进行详细的描述。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVO代码测试以及探究]]></title>
    <link href="iginkgo.cn/15360544284777.html"/>
    <updated>2018-09-04T17:47:08+08:00</updated>
    <id>iginkgo.cn/15360544284777.html</id>
    <content type="html"><![CDATA[
<p>之前对于KVO的实现，都仅仅限于修改了对应属性的<code>set</code>方法的实现，使得在该方法使用前与使用后分别触发不同的方法。现在作者想仔细的看一下具体的细节</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">打印一下基本信息</h2>

<p>说是实现的对方法的替换，那实际上是怎么做到的呢？<br/>
```<br/>
Person *person1 = [[Person alloc] init];<br/>
    Person *person2 = [[Person alloc] init];<br/>
    NSLog(@&quot;添加观察前两个对象的实例 %@, %@ &quot;, person1, person2); //打印实例的地址<br/>
    NSLog(@&quot;添加观察前两个对象的类 %@, %@ &quot;, [person1 class], [person2 class]); //使用class方法获取类<br/>
    NSLog(@&quot;添加观察前，两个对象的类 objc_getClass:%@, %@&quot;, object_getClass(person1), object_getClass(person2));//使用objc_getClass 获取类</p>

<pre><code>[person1 addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:NULL];
NSLog(@&quot;添加观察后两个对象的实例 %@, %@ &quot;, person1, person2);
NSLog(@&quot;添加观察后两个对象的类 %@, %@ &quot;, [person1 class], [person2 class]);
NSLog(@&quot;添加观察后两个对象的类 objc_getClass:%@, %@&quot;, object_getClass(person1), object_getClass(person2));
</code></pre>

<pre><code>
输入的结果：
![](media/15360544284777/15360571965777.jpg)

由以上的结论可以知道几件事情：
1.添加KVO之后，实例对象的地址并没有发生改变
2.添加KVO之后，`[instance class]`获取元类依旧指向person， 但是`object_getClass(instance)`来获取元类则是NSKVONotifying_Person。其中`class`方法拿到的是一个假的结果。`object_getClass`返回的才是一个真正的类型。


## 打印一下具体的IMP
那既然已经知道KVO机制本身是修改了观察元素的IMP，也就是具体的实现，我们打印一下具体的IMP究竟是否发生了改变

</code></pre>

<pre><code>Person *person1 = [[Person alloc] init];
Person *person2 = [[Person alloc] init];

SEL sel = @selector(setName:);

IMP imp1 = [person1 methodForSelector:sel];
IMP imp2 = [person2 methodForSelector:sel];

NSLog(@&quot;添加观察前的的Imp分别是 person1: %p, person2: %p&quot;, imp1, imp2);

[person1 addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:NULL];

imp1 = [person1 methodForSelector:sel];
imp2 = [person2 methodForSelector:sel];

NSLog(@&quot;添加观察后的Imp分别是 person1: %p, person2: %p&quot;, imp1, imp2);
</code></pre>

<pre><code>
最后的输出：

![](media/15360544284777/15360602518137.jpg)

可以看到，person1在属性name添加了KVO之后，其set方法的IMP发生了变化。

结论： 对于属性添加KVO方法后， 其具体的实现会发生改变。

## 继续探究一下， imp发生了哪些变化

在上方代码段的结尾处添加了断点，进行输出打印

![](media/15360544284777/15360604856835.jpg)

结论：
添加KVO后，属性的set方法变为`_NssetObjectValueAndNotify`方法。
而未添加KVO的属性的set方法依旧是 `setName:`

## NSKVONotifying_Person与Person的关系
从上面得到的结论是， person的实例在添加了KVO后，其元类型变为`NSKVONotifying_Person`,那么当前这两个类到底是什么关系呢？

在代码段的最后添加如下代码：

</code></pre>

<pre><code>NSLog(@&quot;%@ 的父类型为 %@&quot;, object_getClass(person1), class_getSuperclass(object_getClass(person1)));
NSLog(@&quot;%@ 的父类型为 %@&quot;, object_getClass(person2), class_getSuperclass(object_getClass(person2)));
</code></pre>

<pre><code>
打印后的结果表示
  ![](media/15360544284777/15360609310566.jpg)

结论： 添加KVO后新生成的NSKVONotifying_Person为 person的派生类。

那么最终生成这个新的派生类与原来的Person又有什么不一样呢？



在代码段最后添加

</code></pre>

<pre><code>NSString *list1 = [self printPersonMethods:object_getClass(person1)];
NSString *list2 = [self printPersonMethods:object_getClass(person2)];

NSLog(@&quot;%@&quot;, list1);
NSLog(@&quot;%@&quot;, list2);
</code></pre>

<pre><code>
![](media/15360544284777/15360665467454.jpg)

最终输出的结果是
![](media/15360544284777/15360666460967.jpg)
可以看到，在派生类中`NSKVONotifying_Person`多了几个方法。其内部也有一个setName：的方法，应该是重写了其父类`Person`中的setName：方法。
重写了dealloc是为了做一些KVO相关的内存释放的操作
重写class方法是隐藏了NSKVONotifying_Person这个类的存在。让外界以为依然是Person相关的类。


## KVO添加以及取消时候的isa指针

</code></pre>

<p>Person *person = [[Person alloc] init];<br/>
    [person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew|<br/>
    NSKeyValueObservingOptionOld  context:NULL];<br/>
    NSLog(@&quot;person-&gt;isa:%@&quot;,object_getClass(person));<br/>
    NSLog(@&quot;person class:%@&quot;,[person class]);<br/>
```</p>

<p><img src="media/15356370719300/15356412308181.jpg" alt=""/></p>

<p>那么有一个问题是， class方法和object_getclass方法都应该是获取元类的方法，有什么不一样的？为什么获取的结果不一样呢？<br/>
class 本身也是获取实例元类型的方法，但是在实现时KVO时，class的方法被底层改写， 因此看到的会依旧指向原生的类。</p>

<p><strong>取消KVO之后</strong>，看一下最终效果</p>

<pre><code>  [person removeObserver:self forKeyPath:@&quot;name&quot;];
    NSLog(@&quot;person-&gt;isa:%@&quot;,object_getClass(person));
    NSLog(@&quot;person class:%@&quot;,[person class]);
</code></pre>

<p><img src="media/15356370719300/15356414025816.jpg" alt=""/></p>

<p>此时可以看到，输出的结果中，两个方法都变成了person</p>

<h2 id="toc_1">分类中新添<strong>属性</strong>的KVO</h2>

<p>通常，如果希望在category中添加属性时， 会使用基于runtime的关联值的方式进行实现。使用<code>objc_getAssociatedObject</code>,<code>objc_setAssociatedObject</code>这两个方式来实现get和set方法。<br/>
那么对于这种情况实现的属性，在进行KVO时，能否正常的获取呢？答案是可以的。</p>

<pre><code>
@implementation Person (Category)
static char *CloudoxKey = &quot;CloudoxKey&quot;;

-(void)setCloudox:(NSString *)cloudox{
    objc_setAssociatedObject(self, CloudoxKey, cloudox, OBJC_ASSOCIATION_COPY_NONATOMIC);
}

-(NSString *)cloudox{
    return objc_getAssociatedObject(self, CloudoxKey);
}
@end
</code></pre>

<pre><code>//在调用的viewController中

  [person addObserver:self forKeyPath:@&quot;CloudoxKey&quot; options:NSKeyValueObservingOptionNew|
    NSKeyValueObservingOptionOld context:NULL];

    person.cloudox = @&quot;11&quot;;
    person.cloudox = @&quot;22&quot;;



</code></pre>

<pre><code>//输出代码


- (void) observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context {
    if([keyPath isEqualToString:@&quot;CloudoxKey&quot;] || [keyPath isEqualToString:@&quot;age&quot;] ){
        NSLog(@&quot;\\noldnum:%@ newnum:%@&quot;,
              [change valueForKey:@&quot;old&quot;],
              [change valueForKey:@&quot;new&quot;]);
    }
    
}

</code></pre>

<h2 id="toc_2">总结</h2>

<ol>
<li>iOS中的KVO是是基于runtime的</li>
<li>某个类的属性首次添加KVO后，会生成一个派生类<code>NSKVONotifying_类名</code>。在派生类中重写被观察的属性的set方法，以此来实现真正的通知。新的类也重写的销毁以及class方法，用于掩护派生类的存在</li>
<li>对象第一次被观察后，该对象的<code>isa</code>指针会指向新生成的派生类。从而确保被监控的属性值发生改变时，调用的是派生类的setter方法。</li>
<li>使用关联值的方法在分类中实现属性，在赋值时是可以触发KVO的。</li>
</ol>

<h2 id="toc_3">参考文档</h2>

<p><a href="https://www.jianshu.com/p/0aa83ac521ba">https://www.jianshu.com/p/0aa83ac521ba</a><br/>
<a href="https://www.jianshu.com/p/dc89f0a2d1ac">https://www.jianshu.com/p/dc89f0a2d1ac</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[论UITableView的dequeueReusableCell方法]]></title>
    <link href="iginkgo.cn/15350236247070.html"/>
    <updated>2018-08-23T19:27:04+08:00</updated>
    <id>iginkgo.cn/15350236247070.html</id>
    <content type="html"><![CDATA[
<p>由一个项目中的问题想到的...</p>

<span id="more"></span><!-- more -->

<p>为什么会想到讨论这个问题呢？以前在使用UITableView的时候，也曾有过疑问，那就是同样是在tableView的缓存中获取cell，下面的两个方法究竟有何不同</p>

<pre><code>func dequeueReusableCell(withIdentifier: String, for: IndexPath) -&gt; UITableViewCell

func dequeueReusableCell(withIdentifier identifier: String) -&gt; UITableViewCell?

</code></pre>

<p>根据官网<a href="https://developer.apple.com/documentation/uikit/uitableview/1614878-dequeuereusablecell">有IndexPath</a>以及<a href="https://developer.apple.com/documentation/uikit/uitableview/1614891-dequeuereusablecell">无IndexPath</a>上的说法，</p>

<p>两者的介绍非常的相似，一个tableView通常会维持一个队列的cel，用以给dataSource复用。调用这个方法时，就是要求tableView返回一个新的cell。如果队列中有现成的cell，那可以直接拿出来复用。如果没有现成的cell，可以通过注册的nib file或者是class重新创建。<br/>
 如果是通过注册的class进行创建，则需要调用方法<code>init(style: reuseIdentifier:)</code>方法进行创建。对于基于nib的class，则是直接通过nib文件进行创建。如果存在可以直接复用的cell，则会调用cell的<code>prepareForReuse()</code>方法。</p>

<p>那么看起来，这两个方法仅仅有两点不一样</p>

<table>
<thead>
<tr>
<th style="text-align: center">dequeueReusableCell(withIdentifier: String, for: IndexPath)</th>
<th style="text-align: center">dequeueReusableCell(withIdentifier: String)</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">不能返回nil</td>
<td style="text-align: center">可以返回nil</td>
</tr>
<tr>
<td style="text-align: center">有indexPath参数</td>
<td style="text-align: center">没有indexPath参数</td>
</tr>
</tbody>
</table>

<p>那么方法中 indexPath 起到了一个什么样的作用呢？ 我们先来看一下最近作者在项目中遇到的一个问题。</p>

<h2 id="toc_0">问题</h2>

<h3 id="toc_1">问题代码</h3>

<p>问题的背景是一个竖直方向的UITableView， 其中一种cell包裹可以水平滑动的UICollectionView。<br/>
啥也不说，上代码。</p>

<pre><code> public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
    guard let cell = tableView.dequeueReusableCell(withIdentifier:  FocusRecommentMediaTableViewCell.cellId, for: indexPath) as?    FocusRecommentMediaTableViewCell else {
        return FocusRecommentMediaTableViewCell()
    }
    cell.collectionView.dataSource = self
    
    //还有可能是其他类型的cell
    return cell
</code></pre>

<p>通过代码我们可以粗略的了解到，当前是一个tableView的返回cell的方法。这个UITableViewCell中又嵌套了一个UICollectionView。</p>

<p>需要提一点的是，我在对应的UITableViewCell的初始化方法中，并没有对其持有UICollectionView的dataSource进行赋值。即 初始化时<code>collectionView.dataSource == nil</code>。</p>

<h3 id="toc_2">意外</h3>

<p>项目中通常跑的都是没有问题的，直到测试到某一个手机 iphone6，iOS9.3<br/>
此时，在<code>缓慢向下滑动的情况下</code>，系统是没有问题的。<br/>
在用户快速向下滑动，即将出现此类cell时，会出现崩溃。</p>

<p>问题描述</p>

<pre><code>UICollectionView dataSource is not set
</code></pre>

<p>在添加了Exception 捕获后，得到以下提示</p>

<pre><code>*** Assertion failure in -[CollectionView _createPreparedSupplementaryViewForElementOfKind:atIndexPath:withLayoutAttributes:applyAttributes:], /BuildRoot/Library/Caches/com.apple.xbs/Sources/UIKit_Sim/UIKit-3512.60.7/UICollectionView.m:1599
</code></pre>

<p>作者有对更高级的iOS系统进行了测试，发现完全没有这个问题。<br/>
那既然提示，DataSource没有进行设置，可能是调用时机的问题，因此，比较粗劣的解决方案是，在UITableView进行初始化，并对UICollectionView进行配置时，设置一个临时的dataSource。<br/>
但是这个解决方案仍然不能解决我的疑惑，经过进一步的定位，发现崩溃的具体位置</p>

<pre><code> guard let cell = tableView.dequeueReusableCell(withIdentifier:  FocusRecommentMediaTableViewCell.cellId, for: indexPath) as?    FocusRecommentMediaTableViewCell else {
        return FocusRecommentMediaTableViewCell()
    }

</code></pre>

<p>即在调用<code>tableView.dequeueReusableCell(withIdentifier: for:)</code>方法时发生了崩溃。在这个时候，UITableViewCell还没有返回给cell， UICollectionView还没有设置dataSource。让我好奇的是，这个时机应该是UICollectionView在进行初始化的时候，<code>没有进行reload操作</code>,为何会调用到dataSource，而在iOS9以后则没有这个问题。而且必须是快速滑动的情况才会发生。</p>

<p>这个时候大家就会问了，上面磨磨唧唧说了半天的为题，跟这次的题目有什么关系？<br/>
是的，将上面的方法换成<code>tableView.dequeueReusableCell(withIdentifier:)</code>,也就是去除掉indexPath这个参数以后，就完全不会出现上面的问题了。</p>

<p>那么关键的问题来了，对于此处非常重要的一个参数 indexPath， 它在此处起了一个什么样的作用？</p>

<p>在developer.apple的文档里， 有一句一笔带过的说明</p>

<blockquote>
<p>This method uses the index path to perform additional configuration based on the cell’s position in the table view.</p>
</blockquote>

<p>说的是<code>func dequeueReusableCell(withIdentifier identifier: String, <br/>
                     for indexPath: IndexPath) -&gt; UITableViewCell</code>这个方法会使用indexPath来进行一些基于cell位置的额外配置。那这是配置是什么呢?</p>

<p>那这个额外的配置是什么呢？</p>

<p>我还要看看</p>

<p>to be continued...</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重构Massive AppDelegate]]></title>
    <link href="iginkgo.cn/15348619116019.html"/>
    <updated>2018-08-21T22:31:51+08:00</updated>
    <id>iginkgo.cn/15348619116019.html</id>
    <content type="html"><![CDATA[
<p>本文是翻译自墙外的一片<a href="http://www.vadimbulavin.com/refactoring-massive-app-delegate/">文章</a>.文章通过分析iOS项目中 <code>AppDelegate</code>中常负担的职能，并将其分为三类，通过引入不同的设计模式将代码进行抽离整合，最终达到单一职能、可重用、已测试的特点。<br/>
译者也在文章的影响下，对当前进行的项目进行了相应的兼容和实现，最终效果还是很不错的。</p>

<span id="more"></span><!-- more -->

<ul>
<li>
<a href="#toc_0">开始</a>
</li>
<li>
<a href="#toc_1">问题</a>
</li>
<li>
<a href="#toc_2">解决方案</a>
<ul>
<li>
<a href="#toc_3">命令模式</a>
</li>
<li>
<a href="#toc_4">组合模式</a>
</li>
<li>
<a href="#toc_5">中介者模式</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">总结</a>
</li>
</ul>


<h2 id="toc_0">开始</h2>

<p>App detelgate连接了你的app与系统。通常它都是整个iOS项目的核心部分。通常，伴随着不断的开发，新特性与功能的增加，AppDelegate最终编程很零碎的东西。</p>

<p>通常把所有的代码都加入appdelegate是十分浪费的，因为它乐意影响整个app。因此，保持这个类的干净与整洁对于一个健壮的项目时非常重要的。</p>

<p>本文探讨了让delegate变得简洁、可测、可重用的几点方式</p>

<h2 id="toc_1">问题</h2>

<p>delegate是整个app的根本的地方。负责与系统与其他的app直接打交道。这使得delegate有非常多的任务， 并且很难进行修改以及扩展。</p>

<p><a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate">苹果官方</a>支持至少要在delegate中持有3种职能。</p>

<p>通过调查大量的开源的app，我总结了通常appDelegate会行使的职能。<br/>
1. 初始化大量的第三方库<br/>
2. 初始化 Core Data stack 以及管理迁移<br/>
3. 配置app的state，用于设置单元测试以及UI测试<br/>
4. 管理推送 本地推送或者远程推送<br/>
5. 配置UIAppearance<br/>
6. 管理UserDataManager：配置初次登录时的flag，保存以及加载数据。<br/>
7. 配置app的角标<br/>
8. 管理后台进程<br/>
9. 管理UI调用栈的配置。选择初始的viewController<br/>
10.播放声音<br/>
11. 关系分析文件<br/>
12. 输出debugLog<br/>
13. 控制转向问题<br/>
14. 实现各种代理协议，尤其是第三方的<br/>
15. 弹出alert  </p>

<h2 id="toc_2">解决方案</h2>

<p>既然我们承认上面这些问题的存在并且这也很重要，那么看一下我们要遵守那些原则</p>

<p>1.维持<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">单一职责原则</a><br/>
2.易扩展<br/>
3.易测试</p>

<h3 id="toc_3">命令模式</h3>

<p>对于每一种delegate的职能，我们创建一个单独的执行类，<br/>
```<br/>
protocol Command {<br/>
    func execute()<br/>
}</p>

<p>struct RegisiterCommand: Command {<br/>
    func execute()<br/>
}</p>

<p>struct SetAppearanceCommand: Command {<br/>
    ...<br/>
}</p>

<p>struct InitialViewControllerCommand: Command {<br/>
 ...<br/>
} <br/>
```</p>

<p>然后创建一个统一的管理类进行管理，管理上面这些command的创建以及执行</p>

<pre><code>final class StartupCommandsBuilder {
    private var window: UIWindow!
    
    func setKeyWindow(_ window: UIWindow)-&gt; StartupCommandsBuilder {
        self.window = window
        return self
    }
    
    func build()-&gt; [Command] {
        return [RegisterCommand(),
                SetAppearanceCommand(),
                InitialViewControllerCommand(window)
                ...]
    }
}
</code></pre>

<p>最终在delegate进行配置的时候，</p>

<pre><code>    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {
        StartupCommandsBuilder()
            .setKeyWindow(window!)
            .build()
            .forEach { $0.execute() }

        return true
    }

</code></pre>

<p>这样将delegate主动调用的工作进行了清晰的切割，并且实现单一职能原则。大大减少了工作工作量</p>

<p>这样做实现了以下的有点：<br/>
1. 每个command都实现了1个功能<br/>
2. 不改动delegate代码就可以直接进行添加，<br/>
3. 每个命令都可以很简单的被单独检测。</p>

<h3 id="toc_4">组合模式</h3>

<p>组合模式使得不同等级的对象可以看成一个实例<br/>
这里主要处理delegate中的代理工作。</p>

<p>对于所有要调用的代理，分别创建单独的代理模式，最终进行进行处理</p>

<pre><code>typealias AppDelegateType = UIResponder &amp; UIApplicationDelegate

class CompositeAppDelegate: AppDelegateType {
    private let appDelegates: [AppDelegateType]

    init(appDelegates: [AppDelegateType]) {
        self.appDelegates = appDelegates
    }

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {
        appDelegates.forEach { _ = $0.application?(application, didFinishLaunchingWithOptions: launchOptions) }
        return true
    }

    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
        appDelegates.forEach { _ = $0.application?(application, didRegisterForRemoteNotificationsWithDeviceToken: deviceToken) }
    }
}
</code></pre>

<p>然后实际工作的时候，需要实现的delegate方法</p>

<pre><code class="language-Swift">//最终每个delegate的实现方法
class PushNotificationsAppDelegate: AppDelegateType {
    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
        // Registered successfully
    }
}

class StartupConfiguratorAppDelegate: AppDelegateType {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {
        // Perform startup configurations, e.g. build UI stack, setup UIApperance
        return true
    }
}

class ThirdPartiesConfiguratorAppDelegate: AppDelegateType {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {
        // Setup third parties
        return true
    }
}
</code></pre>

<p>最终，我们通过一个工厂模式建立创建的逻辑。<br/>
AppDelegate 创建了组合代理，并把他们给所有适合的地方调用</p>

<pre><code>enum AppDelegateFactory {
    static func makeDefault() -&gt; AppDelegateType {
        return CompositeAppDelegate(appDelegates: [PushNotificationsAppDelegate(), StartupConfiguratorAppDelegate(), ThirdPartiesConfiguratorAppDelegate()])
    }
}

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {

    var window: UIWindow?
    let appDelegate = AppDelegateFactory.makeDefault()

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {
        _ = appDelegate.application?(application, didFinishLaunchingWithOptions: launchOptions)
        return true
    }

    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
        appDelegate.application?(application, didRegisterForRemoteNotificationsWithDeviceToken: deviceToken)
    }
}
</code></pre>

<p>这样最终达到的效果是<br/>
1. 每一个子delegate都只行使同一个职能。<br/>
2. 添加新的任务以及delegate很容易， 这并不需要修改主体代码<br/>
3. 所有的代理都很容易进行隔离测试</p>

<h3 id="toc_5">中介者模式</h3>

<p><a href="http://www.vadimbulavin.com/mediator-pattern-case-study/">中介对象</a>通过一个非常隐蔽非直关的形式实现交互。</p>

<p>现在通过实现一个<code>AppLifecycleMediator</code>来传播<code>UIApplication</code>的生命周期事件给各个观察者。这些观察者必须遵守<code>AppLifecycleListener</code>协议</p>

<pre><code>// MARK: - AppLifecycleListener  app的生命周期事件
protocol AppLifecycleListener {
    func onAppWillEnterForeground()
    func onAppDidEnterBackground()
    func onAppDidFinishLaunching()
}

// MARK: - Mediator
class AppLifecycleMediator: NSObject {
    private let listeners: [AppLifecycleListener]

    init(listeners: [AppLifecycleListener]) {
        self.listeners = listeners
        super.init()
        subscribe()
    }

    deinit {
        NotificationCenter.default.removeObserver(self) //在销毁时取消监听
    }

    private func subscribe() {
        NotificationCenter.default.addObserver(self, selector: #selector(onAppWillEnterForeground), name: .UIApplicationWillEnterForeground, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(onAppDidEnterBackground), name: .UIApplicationDidEnterBackground, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(onAppDidFinishLaunching), name: .UIApplicationDidFinishLaunching, object: nil)
    }

    @objc private func onAppWillEnterForeground() {
        listeners.forEach { $0.onAppWillEnterForeground() }
    }

    @objc private func onAppDidEnterBackground() {
        listeners.forEach { $0.onAppDidEnterBackground() }
    }

    @objc private func onAppDidFinishLaunching() {
        listeners.forEach { $0.onAppDidFinishLaunching() }
    }
}

extension AppLifecycleMediator {
    static func makeDefaultMediator() -&gt; AppLifecycleMediator {
        let listener1 = ...
        let listener2 = ...
        return AppLifecycleMediator(listeners: [listener1, listener2])
    }
}
</code></pre>

<p>通过一行代码完成在Appdelegate中的添加</p>

<pre><code>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?

    let mediator = AppLifecycleMediator.makeDefaultMediator()

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {
        return true
    }
}
</code></pre>

<p>中介对象自动的注册了对于所有事件的观察。在AppDelegate只要初始化一次，就能使其正常的工作<br/>
最终满足了文章开头的要求：<br/>
1. 每个监听器都只有一个功能<br/>
2. 不修改appdelegate的代码，很轻易的添加新的观察者/监听器<br/>
3. 每个观察者， 又叫做协调器，可以很容易的做隔离测试。</p>

<h2 id="toc_6">总结</h2>

<p>我们都承认大部分的<code>AppDelegate</code>都非理性的大，过度复杂，行使了过多的职能。我们把这些叫做<code>Massive App Delegates</code><br/>
通过接入这些设计模式，<code>Massive App Delegate</code>可以被分割成多个类，每个类实现单一职能，这样也易于隔离测试。<br/>
这样的代码非常易于修改，不会因为改动造成大量的连带反应。最终非常的领过，易于被抽离以及重用。</p>

<p><a href="http://www.vadimbulavin.com/refactoring-massive-app-delegate/">原文地址</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[问题记录]]></title>
    <link href="iginkgo.cn/15330418099703.html"/>
    <updated>2018-07-31T20:56:49+08:00</updated>
    <id>iginkgo.cn/15330418099703.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<p>今天面临出现了2个问题</p>

<ol>
<li><p>在一个tableView页上，在当前屏幕只显示2个UITableViewCell的情况下， UITableView会针对所有的数据模型，统统创建一遍cell。<br/>
环境： IphoneX  iOS11 <br/>
当前页面数据模型有10个， 实际创建的cell实例有10个。<br/>
期望结果： 初次只会初始化2个cell。<br/>
注意事项： 1.在其它手机上没有这个问题 2.在问题手机上有些页面也没有这个问题。</p>

<p>处理中</p></li>
<li><p>对于UIImageView中显示webp缓慢的问题。<br/>
问题背景：由于图片格式WebP极高的压缩比，可以做到以很小的传输大小实现高清的图片效果， 相比JPEG以及png性能要高很多。因此接口中返回webP作为主要的数据格式。<br/>
但是对于下载好的NSData，在转换为 UIImage的过程中，100K左右的图片大约耗时50-100ms。 400K左右的webP图片大概耗时1500s，效果极差。<br/>
当前采用的是第三方的图片加载框架SDWebImage对webP支持的版本。解读了一下它的源代码，图片的下载以及解析过程完全是异步实现，只有在最后放到UIImageView时才会切换到主线程。<br/>
当前能想到的方案就是在外部webP的大图流入。或是选用其他的图片格式。内部考虑自己实现一套webP图片的解码器，达到高性能的要求。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[autoRelease Pool 总结]]></title>
    <link href="iginkgo.cn/15326191313814.html"/>
    <updated>2018-07-26T23:32:11+08:00</updated>
    <id>iginkgo.cn/15326191313814.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<ul>
<li>
<a href="#toc_0">基本知识点</a>
</li>
<li>
<a href="#toc_1">使用方式</a>
</li>
<li>
<a href="#toc_2">原理</a>
</li>
<li>
<a href="#toc_3">使用场景</a>
</li>
<li>
<a href="#toc_4">疑问</a>
</li>
<li>
<a href="#toc_5">参考文章</a>
</li>
</ul>


<p>主要iOS的研发生涯是使用Swift作为主力语言进行实现的,在项目中也基本没有遇到手动使用autorelease的情况。但是因为这是iOS相关的底层一点的知识，因此书写此文章，作为学习的记录。如果文中有疏漏和错误，也欢迎大家指正。</p>

<h2 id="toc_0">基本知识点</h2>

<blockquote>
<p>Each NSThread object, including the application’s main thread, has an NSRunLoop object automatically created for it as needed.</p>
</blockquote>

<p>我们可以知道每一个线程，包括主线程，都会拥有一个专属的 NSRunLoop 对象，并且会在有需要的时候自动创建</p>

<blockquote>
<p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</p>
</blockquote>

<p>在主线程的 NSRunLoop 的每个 event loop 开始前，系统会自动创建一个 自动释放池 ，并在 event loop 结束时 drain掉 当前的自动释放池，因而在处理完时间之后，会对池中的对象进行释放操作</p>

<blockquote>
<p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.</p>
</blockquote>

<p>每个线程都会维护自己的 自动释放池的栈</p>

<p>同一个对象可以多次加入自动释放池</p>

<p>在自动释放池要销毁时，会向池内的所有对象发送release消息</p>

<h2 id="toc_1">使用方式</h2>

<ol>
<li>在MRC的模式下，需要手动创建一个自动释放池。
对于需要加入池中进行管理的对象，调用 <code>[obj autorelease]</code></li>
<li><p>在ARC的模式下</p>

<pre><code>//OC 代码
@autorelease{   
  //code
}
</code></pre>

<pre><code>//swift 代码

autorelease {
   //code
}

</code></pre></li>
</ol>

<h2 id="toc_2">原理</h2>

<p>每一个线程都会持有一个管理自动释放池的栈，对于该线程中每一个新创建的自动释放池，都会自动加入到栈顶。</p>

<p>对于OC中的代码</p>

<pre><code>@autorelease {
//代码
}
</code></pre>

<p>在经过编译器进行处理后，会转换成以下的代码：</p>

<pre><code>void *context = objc_autoreleasePoolPush();
// {}中的代码
objc_autoreleasePoolPop(context);
//context 指的是哨兵
</code></pre>

<p>实际autoreleasepool的创建之后调用了 AutoreleasePoolPage的方发</p>

<p>我们来看一下<code>AutoReleasePoolPage</code>这个C++实现的代码底做了些什么</p>

<p>AutoreleasePoolPage 是一个4k大小的空间，其基本结构是</p>

<pre><code>//AutoreleasePoolPage
magic_t const magic; //用于校验AutoreleasePoolPage的结构是否完整
id *next; //指向最新添加的autoreleased对象的下一个位置，初始化时指向begin()
pthread_t const thread;  //指向当前指针
AutoreleasePoolPage *const parent; //指向父节点 因此 第一个节点的parent 值为nil
AutoreleasePoolPage *child //指向子节点，最后一个节点的child 值为nil
uint32_t const depth; // 表示深度，从0开始，往后递增1
unit32_t hiwat;
</code></pre>

<p>从上方<code>AutoreleasePoolPage</code>的结构代码可以看出，它同时拥有指向父节点和子节点的指针，也就是说它可以用于组成双向链表。<br/>
而在应用中，<code>AutoreleasePoolPage</code>它4K大小的空间除了保存上面的变量之外，其余的控件都用于保存autorelease的对象指针。当<code>next==begin()</code>时，表示AutoreleasePoolPage为空；当<code>next==end()</code>时，表示AutoreleasePoolPage当前已满，需要添加一个新的AutoreleasePoolPage。并将已满的AutoreleasePoolPage.child指针指向新的page。这样就实现了自动开辟空间来存储autorelease的对象。</p>

<p>当创建一个新的autorelease Pool时，管理autorelease Pool的栈在栈顶添加了新的autorelease Pool时，对应的当前AutorelesePoolPage中的next指向的位置会添加一个哨兵，用于标识此处添加的Autorelease pool。next指针后移， 池中新的autorelease的对象会一次存放在next指针指向的地方。</p>

<p>当需要销毁一个autorelease Pool时，会在AutorelesePoolPage寻找到对应的哨兵的位置，对其向后的所有对象以及以后的AutorelesePoolPage都会执行release操作。</p>

<p>从本质上来说，通过对AutorelesePoolPage的操作，完成了线程中autorelease pool对于添加到池中对象的管理。</p>

<p>并且上面提到的，每个线程中都有一个栈，用于管理autorelease pool，我认为这也是通过 AutorelesePoolPage的双向链表实现的。</p>

<h2 id="toc_3">使用场景</h2>

<ul>
<li>你编写是命令行工具的代码，而不是基于 UI 框架的代码</li>
<li>你需要写一个循环，里面会创建很多临时的对象</li>
<li>这时候你可以在循环内部的代码块里使用一个 @autoreleasepool {}，这样这些对象就能在一次迭代完成后被释放掉。这种方式可以降低内存最大占用</li>
<li>当你大量使用辅助线程</li>
<li>你需要在线程的任务代码中创建自己的 @autoreleasepool {}</li>
</ul>

<h2 id="toc_4">疑问</h2>

<p><a href="https://www.jianshu.com/p/5559bc15490d">文章</a>有一段描述</p>

<blockquote>
<p>MRC下需要对象调用autorelease才会入池, ARC下可以通过__autoreleasing修饰符, 否则的话看方法名, 非alloc/new/copy/mutableCopy开头的方法编译器都会自动帮我们调用autorelease方法.</p>
</blockquote>

<h2 id="toc_5">参考文章</h2>

<p>1.<a href="https://blog.sunnyxx.com/2014/10/15/behind-autorelease/">Sunny的这篇文章讲的很详细</a><br/>
2.<a href="https://blog.ibireme.com/2015/05/18/runloop/">https://blog.ibireme.com/2015/05/18/runloop/</a><br/>
3.<a href="https://imtangqi.com/2016/04/15/autorelease-pool-in-ios/">https://imtangqi.com/2016/04/15/autorelease-pool-in-ios/</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[fastlane相关]]></title>
    <link href="iginkgo.cn/15325341079693.html"/>
    <updated>2018-07-25T23:55:07+08:00</updated>
    <id>iginkgo.cn/15325341079693.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<p>具体的fastlane配置文件在 <code>项目/fastlane/</code>文件内 </p>

<pre><code>Fastfile =&gt; 用来定义所有的lane任务
Appfile =&gt; 是用来存储一些公共信息的，比如app_identifier，apple_id，team_id，itc_team_id等。
Deliverfile =&gt; deliver的配置文件
</code></pre>

<h2 id="toc_0">fastlane安装</h2>

<pre><code>xcode-select --install
sudo gem install fastlane
</code></pre>

<p>其中在安装fastlane时一直出现问题， 按照fastlane在github上给出的说明， 安装了RVM之后，安装的问题得以解决。</p>

<h2 id="toc_1">插件安装</h2>

<pre><code>fastlane install_plugins // 安装插件
</code></pre>

<p>当前项目中分别安装了两个插件</p>

<pre><code>fastlane add_plugin firim // 自动上传fir的插件
fastlane add_plugin versioning
</code></pre>

<h2 id="toc_2">使用</h2>

<p>在cocopods一下安装没有问题的情况下</p>

<p><code>fastlane develop</code> 打包development环境并进行上传<br/>
<code>fastlane adhoc</code>   打包adhoc环境并进行上传<br/>
 测试// 攻略中</p>

<h2 id="toc_3">参考文档</h2>

<ol>
<li><a href="https://docs.fastlane.tools/">官方文档</a></li>
<li><p><a href="https://dongjiawang.github.io/2017/09/13/2017-09-13-fastlane/">自动发布</a></p></li>
<li><p><a href="https://zhuanlan.zhihu.com/p/23180455">https://zhuanlan.zhihu.com/p/23180455</a></p></li>
<li><p>把所有的过程打包成一个可执行文件 <a href="https://www.jianshu.com/p/edcd8d9430f6">方法</a></p></li>
<li><p><a href="http://www.devzhang.cn/2017/07/18/fastLane%E5%85%A5%E9%97%A8%E4%B9%8Bipa%E6%89%93%E5%8C%85/">没事看看</a></p></li>
</ol>

<h2 id="toc_4">额外配置</h2>

<h3 id="toc_5">.gitignore</h3>

<pre><code># fastlane specific
fastlane/report.xml

# deliver temporary files
fastlane/Preview.html

# snapshot generated screenshots
fastlane/screenshots

# scan temporary files
fastlane/test_output
</code></pre>

<h3 id="toc_6">小感悟</h3>

<p>在lane中执行 通常terminal的命令是不ok，<br/>
需要使用 sh &quot;命令&quot;  执行才可以</p>

<h2 id="toc_7">Fastfile配置文件</h2>

<p><a href="https://github.com/DroidDreamer/codeDaily/blob/master/files/Fastfile">demo地址</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最大值连续子序列]]></title>
    <link href="iginkgo.cn/15325305399890.html"/>
    <updated>2018-07-25T22:55:39+08:00</updated>
    <id>iginkgo.cn/15325305399890.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<p>晚上在听得到的上吴军老师讲的《谷歌方法论的专栏》，题目叫做股票的最长增长期。其实也就是求的最大和的子序列方法。</p>

<blockquote>
<p>题目: 对于一个数组，数组内数值可正可负， 求其中和最大的子序列(不考虑空数组的情况)</p>
</blockquote>

<p>例如 [1,3,-2,-5,8,2,-3,6,-2]， 其和最大的子序列为 [8,2,-3,6].</p>

<pre><code>//swift代码
var list = [1,3,-2,-5,8,2,-3,6,-2]
//
</code></pre>

<p>当然，直接拿到这个题目，除了常规上的上来就做之外，还要考虑一下题目是否完整，以及各种边界情况，<br/>
比如<br/>
1.子序列的和溢出的情况<br/>
2.给出的数组为空的情况<br/>
文章中的方法并不会对这些情况作出处理， 但是在自己实现的过程中，一定要考虑到这些可能性。</p>

<h2 id="toc_0">专栏中的解法</h2>

<p>专栏中讲到四种方法，分别按照效率的由低到高进行实现。也就是时间复杂度的由高到低。</p>

<h3 id="toc_1">第一种，暴力遍历所有情况</h3>

<p>遍历每一个起始点和终止点，求两点之间序列的和，保留最大值以及对应的起始点和终止点</p>

<pre><code>var list: [Int] = [2,3,-6,3,5,-2,7,4,-2,-1,2]
class Result {
    var startIndex: Int
    var endIndex: Int
    var count: Int
    
    init(start: Int, end: Int, count: Int) {
        self.startIndex = start
        self.endIndex = end
        self.count = count
    }
}


func getResultFor(array: [Int])-&gt; Result {
    var result = Result(start: -1, end: -1, count: 0)
    for i in 0..&lt;array.count {
        let tempResult = getResultFor(startIndex: i, array: array)
        if result.count &lt; tempResult.count{
            result = tempResult
        }
    }
    return result
}

func getResultFor(startIndex: Int, array: [Int])-&gt; Result{
    var temMax = Int.min
    var endIndex: Int = -1
    for j in startIndex..&lt;array.count {
        let count = getCount(startIndex: startIndex, endIndex: j, array: array)
        if temMax &lt; count {
            temMax = count
            endIndex = j
        }
    }
    return Result(start: startIndex, end: endIndex, count: count)
}


func getCount(startIndex: Int, endIndex: Int, array:[Int])-&gt; Int {
    if startIndex &lt;= endIndex, array.count &gt; endIndex {
        var count = 0
        for i in startIndex...endIndex {
            count += array[i]
        }
        return count
    }else {
        fatalError()
    }
}
</code></pre>

<h3 id="toc_2">第二种，优化一些的算法</h3>

<p>遍历每一个起始点，然后遍历每一个终止点，对比每次循环得出的最大值，比较之后求出最值结果</p>

<pre><code>
var list: [Int] = [2,3,-6,3,5,-2,7,4,-2,-1,2]


class Result {
    var startIndex: Int
    var endIndex: Int
    var count: Int
    
    init(start: Int, end: Int, count: Int) {
        self.startIndex = start
        self.endIndex = end
        self.count = count
    }
}


func getResultFor(array: [Int])-&gt; Result {
    var result = Result(start: -1, end: -1, count: 0)
    for i in 0..&lt;array.count {
        let tempResult = getResultFor(startIndex: i, array: array)
        if result.count &lt; tempResult.count{
            result = tempResult
        }
    }
    return result
}

func getResultFor(startIndex: Int, array: [Int])-&gt; Result{
    var temMax = Int.min
    var count: Int = 0
    var endIndex: Int = -1
    for j in startIndex..&lt;array.count {
        count += list[j]
        if temMax &lt; count {
            temMax = count
            endIndex = j
        }
    }
    return Result(start: startIndex, end: endIndex, count: count)
}
</code></pre>

<p>这种解法的时间复杂度为O(n2) n的平方<br/>
在第一种解法的基础上，如果假定了起始点，那么该点到终止点的总和可以根据前一个点的结果求和得出。<br/>
<code>Sum(n) = Sum(n-1) + list[n]</code>. </p>

<p>这里需要注意的是， 在getResultFor的两个方法中，每次都把array做为参数进行了传递。通常意义上来说，一个Array作为一个值类型，在作为参数进行调用时可能会开辟新空间，因此很多语言上来说是不建议这么做的。Swift作为一个新生的语言，值类型都经过了优化，那就是在调用之后，默认先不进行copy，只有在对该值类型进行修改时才会临时copy。</p>

<h3 id="toc_3">第三种，分治算法</h3>

<p>求一个数组的最大连续子序列和，如果采用一分为二的角度来看，将数组分为两部分，则可能出现3种情况，就是1.最大子序列在左侧子数组中 2.最大子序列在右侧子数组中 3. 最大子序列横跨中心点，在左右两个子数组中分别占有一部分。<br/>
对于第1，2中情况，可以直接继续进行递归处理。<br/>
对于第三种情况， 对于左子数组，从右侧节点为起始点，向左寻找一个终点，使区间和最大。<br/>
               对于右侧数组，从左侧节点为起始点，向右寻找一个终点，使区间和最大，并将以上两者的和相加，即为最终结果。</p>

<pre><code>var list: [Int] = [2,3,-6,3,5,-2,7,4,-2,-1,2]

func getResult(array: [Int], left: Int, right: Int)-&gt; Int {
    if left &gt;= right {
        return array[right] &gt; 0 ? array[right] : 0
    }
    
    var middle = (right + left) / 2
    let leftMax = getResult(array: array, left: left, right: middle)
    let rightMax = getResult(array: array, left: middle + 1, right: right)
    let middleMax = getLeftSubMax(array: array, left: left, middle: middle) + getRightSubMax(array: array, middle: middle + 1, right: right)
    
    return Swift.max(leftMax, rightMax, middleMax)
}


func getLeftSubMax(array:[Int], left: Int, middle: Int)-&gt; Int {
    var max = 0
    var count = 0
    var index = middle
    
    while (index &gt;= left) {
        count += array[index]
        if max &lt; count {
            max = count
        }
        index -= 1
    }
    return count
}


func getRightSubMax(array:[Int], middle: Int, right: Int)-&gt; Int {
    var max = 0
    var count = 0
    var index = middle

    while (index &lt;= right) {
        count += array[index]
        if max &lt; count {
            max = count
        }
        index += 1
    }
    return max
}



//最终结果
getResult(array: list, left: 0, right: list.count - 1)

</code></pre>

<h3 id="toc_4">第四种(该题代码实现有问题)</h3>

<p>整个过程可以延续这么一个思路：<br/>
对于一个数组 list，对于某个确定的起始点，比如下标start开始，我们想知道子序列是终止在 下标为k的地方好的，还是终止在下标为k+1的位置好呢，这主要看 list[k+1]这个值是否为正。如果为正，那么显然应该吧k+1这个节点收纳进来。如果未负，不能单纯的判断需要抛弃，而是要看从该点之后的累积值是否可以为正。总的来说，就是看从start点开始，到最终哪一天结束的累积增幅最大。这个时候，end点肯定是最优终止点。</p>

<p>根据这个思路，<br/>
以下标0为起始点，找出持续增幅最大的一个点 （遍历k次），可以找出end点。<br/>
将数组反过来，以 （n-1） 为起始点，0为终止点，按照同样的逻辑，可以找到start点。<br/>
这样，start-end这个区间就是所求的结果区间。</p>

<p>上面的语言比较啰嗦，总的来说，正向遍历一遍，可以找到最佳的终止点。<br/>
因为这个数组的解法具有对称性。反着做逻辑也是一样的， 反向遍历一遍，可以找到最佳的起始点。</p>

<pre><code>var list: [Int] = [2,3,-6,3,5,-2,7,4,-2,-1,2]
class Result {
    var startIndex: Int
    var endIndex: Int
    var count: Int
    
    init(start: Int, end: Int, count: Int) {
        self.startIndex = start
        self.endIndex = end
        self.count = count
    }
}



func leftToRightSumList(array: [Int])-&gt; [Int] {
    var sum: [Int] = []
    var count = 0

    return array.map({ (value) -&gt; Int in
        count += value
        return count
    })
}

func rightToSumList(array: [Int])-&gt; [Int]{
    var sum: [Int] = array
    
    var index = array.count - 2
    while (index &gt;= 0) {
        sum[index] = sum[index] + sum[index+1]
        index -= 1
    }
    return sum
}

func getIndexWhenValueMax(array: [Int])-&gt; Int {
    var max = 0
    var result = 0
    
    for index in 0..&lt;array.count {
        if max &lt; array[index] {
            max = array[index]
            result = index
        }
    }
    return result
    
}

func getMaxListValue(array: [Int])-&gt; Int {
    var leftSumList = leftToRightSumList(array: array)
    var rightSumList = rightToSumList(array: array)
    var rightIndex = getIndexWhenValueMax(array: leftSumList)
    var leftIndex = getIndexWhenValueMax(array: rightSumList)
    var count = 0
    for index in leftIndex...rightIndex {
        count += array[index]
    }
    return count
}
getMaxListValue(array: list)

</code></pre>

<p>时间复杂度 O(n)</p>

<p>总结1: 思维高度决定一个人的境界。<br/>
总结2: 对称性这个思维工具真的很重要</p>

<h2 id="toc_5">个人解法</h2>

<p>首先构建一个新的数组sum[], 其中存储的每个元素sum[i] = a[0]+ a[1] +..a[i],<br/>
也就是 sum[0] = a[0], sum[i] = sum[i-1] + a[i]</p>

<pre><code>var sum: [Int] = []
var count: Int = 0
for i in (0..&lt;list.size) {
  if i == 0 {
   sum.append(a[0])
   }else {
     sum.append(sum[i-1] + a[i])
   }
  count += list[i]
  sum.append(count)
}

</code></pre>

<p>然后最大子序列的问题，也就变成了数组sum中，差最大的两个值的问题。<br/>
若最大子序列为 a[left]... a[right], 则 sum[right]与sum[left-1]的差值也是最大的。</p>

<p>因此需要求sum数组中差值最大的情况。当然，要求下标 right &gt; left</p>

<pre><code>var sum: [Int] = []
for index in 0..&lt;list.count {
    if index == 0 {
        sum.append(list[0])
    }else {
        sum.append(sum[index-1] + list[index])
    }
}

var minValue: Int = 0
var minValueIndex: Int = 0

var max: Int = 0
var left: Int = 0
var right: Int = 0

sum.enumerated().forEach{ (index, value) in
    if minValue &gt; value {
        minValue = value
        minValueIndex = index
    }
    
    let separatedValue = value - minValue
    if separatedValue  &gt; max {
        max = separatedValue
        right = index
        if left != minValueIndex + 1 {
            left = minValueIndex + 1
        }
    }
}


//最终，最大和的子序列 起始点下标为 left， 终止点下标为right，其子序列的和为max
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对于首页的优化]]></title>
    <link href="iginkgo.cn/15324828408733.html"/>
    <updated>2018-07-25T09:40:40+08:00</updated>
    <id>iginkgo.cn/15324828408733.html</id>
    <content type="html"><![CDATA[
<!-- 进行中 -->

<p>当前页面中存在的问题</p>

<pre><code>switch model.style {
case .news: 
    let cell = tableView.dequeue(&quot;newsCell&quot;) //config
    //...配置
    return cell
case .video:
     let cell = tableView.dequeue(&quot;videosCell&quot;) //config
    //...配置
    return cell
case .pic:
     let cell = tableView.dequeue(&quot;picsCell&quot;) //config
    //...配置
    return cell
case .beauty:
     let cell = tableView.dequeue(&quot;beautyCell&quot;) //config
    //...配置
    return cell
case .bigImage:
     let cell = tableView.dequeue(&quot;bigImageCell&quot;) //config
    //...配置
    return cell
default: ...
}
</code></pre>

<p>实际页面涉及到的cell种类不止这些，并且在未来的开发过程中会随着app特性的增加而增长，因为每次需要维护和更新时对整个大的代码块进行修改就编程一个非常杂乱的过程，稍有不慎还会影响整体的逻辑。那这里我们需要利用协议的特性进行设计。<a href="https://xiaozhuanlan.com/topic/2537681490">相关参考</a></p>

<p>实际项目中定义了一个协议，用来表示整个的数据类型</p>

<pre><code class="language-表示我们的基本类型以及转换后的类型">protocol ParseMessageType{
    associatetype: Original
    associatetype: ParseResult
}
</code></pre>

<p>那<code>Original</code>-&gt;<code>ParseResult</code>的转换步骤通过一个 parser来完成， 叫做<code>MessageParser</code></p>

<pre><code>protocol MessageParser {
 
 associatetype: Message
 associatetype: Target: ParaseMessageType where Message == Target.Original
    func parse(messgae: Message)-&gt; Target.ParsedResult
}

</code></pre>

<p>对于Target遵守 ParaseMessageType 的协议， 并且它的 original和message一致， 这就对parse方法的返回值进行了限定，编译过程中进行类型检查时会进行严格的类型匹配。</p>

<p>在具体MessageType实现的过程中</p>

<pre><code>final class ParsedChatMessage: ParsedMessageType {
    let output: NSAttributedString
    let original: ChatMessage
    
    init(message: ChatMessage){
        original = messgae
        let parser = Parser()
        self.output = parser.parse(message: message)
    }
}

struct Parser: MessageParser {
    typealias Target = ParsedChatMessage
    func parse(message: ChatMeaasge)-&gt; NSAttributeString {
     let reuslt = ...
     return .init(attributedString: result...)
    }
}


</code></pre>

<p>那么实际中的本地效果呢：</p>

<p>FeedModel   IndexProtocol   cellViewModel1  cellViewModel2cellViewModel3</p>

<p>在 feedModel，<br/>
在feedModel中实现fakeModel<br/>
FeedModel-&gt; IndexProtocol<br/>
fakeModel-&gt; IndexProtocol<br/>
TopicModel -&gt; IndexProtocol</p>

<p>对应的不同的cell， </p>

<p>此外，需要进一步实践的</p>

<p><a href="http://xiaozhuanlan.com/topic/6104325798">delegate改进</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[首页的优化记录]]></title>
    <link href="iginkgo.cn/15324314483651.html"/>
    <updated>2018-07-24T19:24:08+08:00</updated>
    <id>iginkgo.cn/15324314483651.html</id>
    <content type="html"><![CDATA[
<p>记录一个复杂页面的优化过程</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">第一次优化</h2>

<h3 id="toc_1">当前现状</h3>

<p>当前的页面有三个文件</p>

<pre><code>viewController.swift //处理交互和主体逻辑
viewController.xib   //当前页面的主要view 
viewModel.swift      //当前页面的主要网络请求、数据转换与存储、信号
</code></pre>

<p>当前的viewController是一个非常典型的<strong>“Massive view Controller”</strong>.<br/>
整个viewConttroller 大概1000行代码。</p>

<p>大体梳理一下具体的实现：</p>

<ol>
<li><p>初始化方法<br/>
普通view的初始化    10<br/>
tableView初始化    45<br/>
网络请求（失败和成功的UI变化）            20<br/>
事件监听        60行</p></li>
<li><p>tableView中涉及到的cell有8种混杂，<br/>
使用代码(如下方代码)的方式进行解析</p></li>
</ol>

<pre><code>switch viewmodel.list[indexpath.row].style {
case .news: //...
case .video: //...
case .image:// ...
...
}
</code></pre>

<p>其中方法<code>cellForRowAtIndex</code>  90行<br/>
方法 <code>cellDidSelect</code>  65行</p>

<ol>
<li>tableView上某些cell包含UICollectionView，需要具体实现<code>UICollectionDataSource</code>、<code>UICollectionDataSource</code>实现   60行</li>
<li>tableView上具体点赞按钮、关注按钮、收藏按钮等需要具体使用回调来相应   90行</li>
<li>其余的辅助方法  大约200行左右。</li>
</ol>

<p>当前代码结构过于雍容，像《代码大全》，《代码简洁之道》等总结代码规范的书籍，通常建议一个文件不要超过200行，最多不要超过400行。一个1000行左右的文件已经让人读起来非常吃力，并且考虑到业务会经常修改的情况，清晰的脉络是非常必要的。</p>

<h3 id="toc_2">当前进行的操作</h3>

<ol>
<li>将各种涉及到cell idendifier，cell height等跟固定的cell相关的一些常量，全部提取到cell本身代码中去。</li>
<li>去除整个页面中的魔幻数（突然出现的字符串、常量等），用一个变量进行代替。</li>
<li>创建一个<code>TableViewDataSource： NSObject, UITableViewDataSource</code>作为tableView的数据源。将对应的代码切换过去。</li>
</ol>

<h3 id="toc_3">遇到的问题</h3>

<p>在进行DataSource剥离的时候,出现tableView中高度失调的问题。</p>

<pre><code>//ViewController.swift
tableView.dataSource = TableViewDataSource()
tableView.delegate = self
</code></pre>

<pre><code>//UITableViewDataSource
public func numberOfSections(in tableView: UITableView)-&gt; Int
public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int
public func tableView(_ tableView: UITableView, cellForRow indexPath: IndexPath)-&gt; UITableViewCell
public func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat
</code></pre>

<p>调试许久发现，返回高度的方法<strong>不属于</strong><code>UITableViewDataSouce</code>.<br/>
问题的发生源于我的一个观念： DataSource通常是用于view在controller中获取所需数据、内容、view。 delegate是处理一些响应、监听的事件的。 但是从这次的问题来看，显然不是如此</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ObjectMapper学习]]></title>
    <link href="iginkgo.cn/15321858704283.html"/>
    <updated>2018-07-21T23:11:10+08:00</updated>
    <id>iginkgo.cn/15321858704283.html</id>
    <content type="html"><![CDATA[
<p>ObjectMapper<br/>
最近在写Mirror的时候，一直在考虑如何自动实现JSON 与Object之间的解析与赋值问题，而不需要手动进行key值的配置。因此对于当前Swift中常用的几个框架比较好奇。因此我打算解读一下 ObjectMapper是如何实现的。。</p>

<span id="more"></span><!-- more -->

<p>看一下ObjectMapper的结构</p>

<pre><code>Map.swift
Mapper.swift
Mappable.swift
MapError.swift

...Transform.swift


</code></pre>

<p>下面介绍一下主要的职能部分</p>

<h3 id="toc_0">Mapper</h3>

<p>Mapper是一个操作类，用于操作本地赋予的各种数值，list, dictionary等不同的类型，将类型统一后 生成对应的Map进行赋值操作。<br/>
它是控制整个转换操作过程中最大的操作类。</p>

<p>//TODO: 需要画图进行演示。</p>

<h4 id="toc_1">主要方法</h4>

<p>方法列表中的方法主要是兼容可能出现的各种输入形式，并最终分析目标类型的元素或者list， dictionary等。</p>

<pre><code>//class Mapper&lt;N: BaseMappable&gt;
//泛型N表示目标类型
public func map(JSONObject: Any?, toObject object: N) -&gt; N
public func map(JSONString: String, toObject object: N) -&gt; N
public func map(JSON: [String : Any], toObject object: N) -&gt; N
public func map(JSONString: String) -&gt; N?
public func map(JSONObject: Any?) -&gt; N?
public func map(JSON: [String : Any]) -&gt; N?
public func mapArray(JSONString: String) -&gt; [N]?
public func mapArray(JSONObject: Any?) -&gt; [N]?
public func mapArray(JSONArray: [[String : Any]]) -&gt; [N]
public func mapDictionary(JSONString: String) -&gt; [String : N]?
public func mapDictionary(JSONObject: Any?) -&gt; [String : N]?
public func mapDictionary(JSON: [String : [String : Any]]) -&gt; [String : N]?
public func mapDictionary(JSONObject: Any?, toDictionary dictionary: [String : N]) -&gt; [String : N]
public func mapDictionary(JSON: [String : [String : Any]], toDictionary dictionary: [String : N]) -&gt; [String : N]
public func mapDictionaryOfArrays(JSONObject: Any?) -&gt; [String : [N]]?
public func mapDictionaryOfArrays(JSON: [String : [[String : Any]]]) -&gt; [String : [N]]?
 public func mapArrayOfArrays(JSONObject: Any?) -&gt; [[N]]?
public static func parseJSONStringIntoDictionary(JSONString: String) -&gt; [String : Any]?
public static func parseJSONString(JSONString: String) -&gt; Any?
</code></pre>

<h3 id="toc_2">Map</h3>

<p>Map 提供一个基础的容器， 在获取JSON内容或者Object之后，提供一些基本的状态标识，数据存储</p>

<h4 id="toc_3">关键属性</h4>

<pre><code>public internal(set) var JSON: [String: Any] = [:] //存放要操作的json
public internal(set) var isKeyPresent = false// 当前key值对应的值是否存在
public internal(set) var currentValue: Any? //当前key值所对应的value值
public internal(set) var currentKey: String? //当前的key值
</code></pre>

<p>举了例子再进行说明<br/>
对于一个对象进行转化时，</p>

<pre><code>class Person: Mappable {
var age: Int?
var gender: String?
var height: Double?

func mapping(map: Map){
  age &lt;- map[&quot;age&quot;]
    gender &lt;- map[&quot;gender&quot;]
    height &lt;_ map[&quot;height&quot;]
}
}
</code></pre>

<p>调用方法</p>

<pre><code>Mapper&lt;Person&gt;().map(json: JSON) //生成对象
</code></pre>

<p>这边在进行转换的过程中，对于一个json，生成一个Map用于存储json并进行简单的数据操作。 在对于具体属性进行配给时，<br/>
具体的步骤<br/>
1. 处理<code>age &lt;- map[&quot;age&quot;]</code>时， 整个map的对象在map[“age”]的方法时， 调用下标方法， 设置 currentKey = “age”， currentValue = json[“age”], 由于要查找的key值在json中确实存在，isKeyPresent = true<br/>
2. 处理<code>gender&lt;-map[&quot;gender&quot;]</code>, 加入json这个字典中不存在json[“gender”],<br/>
则当前 <code>isKeyPresent=false</code>, currentValue = nil<br/>
3. 处理height值时，使用相同的逻辑进行处理</p>

<p>主要方法</p>

<pre><code>init(json: [String:Any],...) //进行json的赋值
subscript() //下标的方法，本身状态经过一定的修正，获取下标在json中对应的值，然后返回本身
func value&lt;T&gt;()-&gt; T? // 将subscripy中获取的值，判断是可转为用于需要的类型，并转换。

</code></pre>

<p>这个部分中的value方法是我非常感兴趣的地方。 因为整个Map文件只有这一个地方涉及到泛型的问题，而我好奇的是，泛型的类型是如何进行推断的。</p>

<pre><code>public func value&lt;T&gt;() -&gt; T? {
    let value = currentValue as? T 
  ...
    ... 
    ...
}
</code></pre>

<p>这个类型转换中，最终进行判断的类型是如何确定的呢？</p>

<p>让我们来看一下相关的调用方法：</p>

<pre><code>//Operator.swift
public func &lt;- &lt;T&gt;(left: inout T, right: Map) {
    switch right.mappingType {
    case .fromJSON where right.isKeyPresent:
        FromJSON.basicType(&amp;left, object: right.value()) //注意
    case .toJSON:
        left &gt;&gt;&gt; right
    default: ()
    }
}
</code></pre>

<pre><code>//FromJSON.swift
internal final class FromJSON {
    class func basicType&lt;FieldType&gt;(_ field: inout FieldType, object: FieldType?) {}
}
</code></pre>

<p>那让我们来梳理一下泛型T的推断过程</p>

<pre><code>func &lt;- &lt;T&gt;(left: inout T, right: Map)
func basicType&lt;FieldType&gt;(_ field: inout FieldType, object: FieldType?)
func value&lt;T&gt;()-&gt; T?
</code></pre>

<p>砰砰，划重点：<br/>
basicType方法声明了一个泛型，约束输入的两个参数属性应该是相同的。<br/>
而在Operator.swift中的方法，left这个参数类型 和 right.value()类型相同。<br/>
由于value()这个方法声明为一个泛型，这个类型是需要被推断出来的，因此最终确定是需要通过 left的属性来确定。<br/>
即： <strong>根据操作符</strong><code>&lt;-</code><strong>的做参数的属性来确定返回值的类型</strong><br/>
我认为这是类型推断非常强大的一点。</p>

<p>同样的, 我在playground上实验了类似的例子，说明编译器对于泛型中类型的推导具有延续性。<br/>
写一个泛型类型推导的例子<a href="https://github.com/DroidDreamer/codeDaily/blob/master/Generic%20type%20inference.playground/Contents.swift">泛型例子</a><br/>
//TODO: 此处添加类似的代码。Generic type inference</p>

<p>…Transform: 针对特定的类型设置转换规则</p>

<p>//TODO: 未完待续</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中的反射  Mirror (上) 认识和基本使用]]></title>
    <link href="iginkgo.cn/15321351019730.html"/>
    <updated>2018-07-21T09:05:01+08:00</updated>
    <id>iginkgo.cn/15321351019730.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">简介</h2>

<blockquote>
<p>Reflection: In computer science, reflection is the ability of a computer program to examine, introspect, and modify its own structure and behavior at runtime     --wikipedia</p>
</blockquote>

<!-- more -->

<p>在计算机科学中，反射指的是在计算机程序在运行时 检查，introspect， 修改自身结构以及行为的能力。</p>

<p><a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)">wikipedia介绍</a></p>

<p>在正常的iOS开发中，由于OC语言有着强大的运行时特性，它的能力要比反射高的多，因此在过去OC实现的iOS项目中并不多见。 Swift作为一个标准且强大的静态语言，本身并没有runtime的相关能力，只提供了<code>Mirror</code>来实现一些反射的特性。</p>

<h2 id="toc_1">Mirror基本介绍</h2>

<p><a href="https://developer.apple.com/documentation/swift/mirror">官方文档</a></p>

<h3 id="toc_2">表述：A representation of the substructure and display style of an instance of any type.</h3>

<p>对于一种类型内部结构的描述以及具体实例的展示类型</p>

<h3 id="toc_3">创建</h3>

<pre><code>class Car {
    var price: Int
    var color: String = &quot;red&quot;
    
    init(price: Int) {
        self.price = price
    }
}

let car = Car(price: 20000)
let mirror = Mirror(reflecting: car)
</code></pre>

<p>使用<code>Mirror</code>的<code>reflecting</code>方法，传出一个静态的实例， 获取该实例类型的反射结果</p>

<h3 id="toc_4">内部结构</h3>

<h4 id="toc_5">property</h4>

<pre><code>let children: Mirror.Children
A collection of Child elements describing the structure of the reflected subject.

var customMirror: Mirror
var description: String
let displayStyle: Mirror.DisplayStyle?
A suggested display style for the reflected subject.

let subjectType: Any.Type
The static type of the subject being reflected.

var superclassMirror: Mirror?
A mirror of the subject’s superclass, if one exists.

</code></pre>

<p>其中需要重点介绍的是 <code>Mirror.children</code></p>

<pre><code> typealias Mirror.Child = (label: String?, value: Any)
 typealias Mirror.Children = AnyCollection&lt;Mirror.Child&gt;
</code></pre>

<p>我们通常使用Mirror的反射来获取一个类型的内部变量，都是通过<code>Mirror.Child</code>来获取的。<br/>
 对于内部变量， <code>label</code>用于表述其内部参数名， <code>value</code> 表示其参数值。<br/>
 下面我们写一个例子，进行观察</p>

<p>示例</p>

<pre><code> for item in mirror.children {
    print(&quot;当前属性名为\(item.label), 属性的值为\(item.value)&quot;)
}
</code></pre>

<p>其输出结果为：<br/>
当前属性名为Optional(&quot;price&quot;), 属性的值为20000<br/>
当前属性名为Optional(&quot;color&quot;), 属性的值为red</p>

<p>当然，我们也看到，Mirror.child 作为一个 tuple，其第一个属性<code>label</code>是一个可选型。这是因为Mirror支持的类型很多，后面会进一步介绍， 对于一个 <code>Array</code> 进行反射，只会对属性值进行展示，却没有属性名， 这种情况下 属性名是会为空的。</p>

<h4 id="toc_6">descendant</h4>

<p>返回给定路径的对象，如果路径错误，则返回为nil。</p>

<pre><code>func descendant(MirrorPath, MirrorPath...) -&gt; Any?
Returns a specific descendant of the reflected subject, or nil if no such descendant exists.

protocol MirrorPath
A protocol for legitimate arguments to Mirror’s descendant method.
</code></pre>

<p>这个方法介绍给有多层类型嵌套的情况<br/>
例如，我们先重新修改 要检测的实例类型,在<code>Car</code>中嵌套一个class。</p>

<pre><code>class Driver {
    var gender: String = &quot;男&quot;
    var age: Int = 30
}

class Car {
    var price: Int
    var color: String = &quot;red&quot;
    var driver = Driver()
    
    init(price: Int) {
        self.price = price
    }
}

let car = Car(price: 20000)
let carMirror = Mirror(reflecting: car)
let mirror = Mirror(reflecting: car)
for item in mirror.children {
    print(&quot;当前属性名为\(item.label), 属性的值为\(item.value)&quot;)
}
</code></pre>

<p>实际情况是，对于 driver这个属性，无法进行清晰的表述<br/>
输出结果：<br/>
当前属性名为Optional(&quot;price&quot;), 属性的值为20000<br/>
当前属性名为Optional(&quot;color&quot;), 属性的值为red<br/>
当前属性名为Optional(&quot;driver&quot;), 属性的值为__lldb_expr_14.Driver</p>

<p>此时第三条driver，就是直接打印的driver的对象。<br/>
当然，如果需要对driver进行进一步输入，就要继续向下做下去了。</p>

<p><code>descendant</code> 这个方法可以返回给定路径的属性值。<br/>
例如：</p>

<pre><code>let gender = mirror.descendant(&quot;driver&quot;, &quot;gender&quot;)
print(gender)car
</code></pre>

<p>输出结构为 Optional(30)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[随想系列(-)]]></title>
    <link href="iginkgo.cn/15319270059690.html"/>
    <updated>2018-07-18T23:16:45+08:00</updated>
    <id>iginkgo.cn/15319270059690.html</id>
    <content type="html"><![CDATA[
<p>最近走上上班的路上，常常会触发一些联想。这可能就是乱七八糟的书多了，就会触发跨区域的传输。</p>

<p>今天思考了个问题， <strong>人为什么要学习呢？</strong><br/>
最近两天也在刷算法的一些问题。发现很多问题的解决确实是需要一些奇思妙想，这些天马行空的思想需要一个卓越的大脑来实现。然而大部分算法的实现都是有<strong>套路</strong>的。作为普通劳动力里的我，也就只能通过不断的接触和实践才能慢慢掌握。<br/>
这里就把解题的人分为两种类型：聪明人和平庸的人。 <br/>
针对一个问题，聪明人可能直接给出答案，平庸的人呢，要针对给出的细节，进行反复的思考。<br/>
这里就体现了不同的人，他的思维深度和广度。<br/>
思维的深度指的是，针对一个一些底层条件和细节，是否能够推断出高层次的结论，进而由这些高层次的结论，推断出想要的结果。 这个已知条件实现的“升级”，也就是我们平时常说的知识点了。对于不了解这些知识点的人，对于那些底层的细节，也都是束手无策的。<br/>
我又想到以前讨论的很火热的一个问题”现在搜索软件已经这么方便了，可以直接在网络搜索我需要的结果，那我还要花时间学习，有必要吗?“  我的结论是——非常有必要。<br/>
coursera上有一门课程，叫做《Learn How to learn》, 里面介绍了学习知识的一种理论： 我们学习的东西在大脑中就是一个点，与该知识相关的知识就是另外一个点，当我们学习并深化之后，两个点就会建立一个连接，在大脑思考问题时，考虑到某个点，就很自然的通过连接到达其他的相关知识点。这就是推论、联想。连接是可以通过不断的思考，练习来强化的。这样，随着点的越来越多，连接的越来越多，最终形成了牢固的知识体系。我们在考虑一个问题的时候，可以藉由这个知识网络到达体系内的任意一点。这也代表了在某一个领域内的广度和深度。而这一点是很难通过网络引擎来替代。<br/>
回到解题的问题上来，知识体系丰富的人，对于现有的条件，很容易在网络中寻找相关的信息，利用这些相关信息来处理问题。而体系狭窄，萎缩的人，想破脑袋也很难想的出来，临时使用搜索引擎，针对相关的知识进行学习，其挑选、吸收的过程就需要很大的成本。</p>

<p>我当前希望自己做的，就是不断强化和延伸这样的知识网络。</p>

<p>第二个想法呢， 每天做一件让自己赞叹的事情吧。让自己的一天显得与众不同。<br/>
第三个想法呢 克服习惯的惯性，克服欲望。完成一个完整的流程，好好的做完一件事。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WWDC 2018 Swift 4.2 新特性]]></title>
    <link href="iginkgo.cn/15282735197620.html"/>
    <updated>2018-06-06T16:25:19+08:00</updated>
    <id>iginkgo.cn/15282735197620.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<p><a href="https://devstreaming-cdn.apple.com/videos/wwdc/2018/401ieeclipzse3tz3fg/401/401_hd_whats_new_in_swift.mp4?dl=1">视频下载地址</a></p>

<ul>
<li>
<a href="#toc_0">优化</a>
</li>
<li>
<a href="#toc_1">在编译方便的优化</a>
<ul>
<li>
<a href="#toc_2">Compliation Mode</a>
</li>
<li>
<a href="#toc_3">Optimization Level</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">Swift语言特性</a>
<ul>
<li>
<a href="#toc_5">CaseIterable协议</a>
</li>
<li>
<a href="#toc_6">随机数生成以及打乱操作</a>
</li>
<li>
<a href="#toc_7">Enhanced conditional conformances</a>
<ul>
<li>
<a href="#toc_8">运行时的类型询问</a>
</li>
<li>
<a href="#toc_9">Optional、Array、Dictionary等对协议的默认实现</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_10">Hashable（未完待续）</a>
</li>
</ul>


<p>不得不赞叹一句 Xcode10下的playground运行起来真是比以前好到不行</p>

<h2 id="toc_0">优化</h2>

<p><code>TODO: 待补充</code></p>

<h2 id="toc_1">在编译方便的优化</h2>

<p><img src="media/15282735197620/1D720CC705576DB05D71C805EFE2BBB6.jpg" alt="1D720CC705576DB05D71C805EFE2BBB6"/></p>

<p>主要体现在两个方面</p>

<h3 id="toc_2">Compliation Mode</h3>

<p>在debug模式下建议开始<code>Incremental</code>模式，会大大提升效率<br/>
 <code>Whole Module</code>模式意味着在每次build会将全局进行build，耗时较长</p>

<h3 id="toc_3">Optimization Level</h3>

<p>其中有3个选项 <code>No optimization[-Onone]</code>,<code>Optimize for Speed [-O]</code>,<code>Optimize for Size[-Osize]</code><br/>
其中<code>Optimize for Size</code>模式是这次更新的一大主题<strong>Code Size</strong>的一部分，在开启之后， Code size可能会减少 10% - 30%， 但是运行时的特性可能会降低 5%。</p>

<h2 id="toc_4">Swift语言特性</h2>

<h3 id="toc_5">CaseIterable协议</h3>

<p>swift中的枚举类型在实现CaseIterable协议后，可以对每个case进行遍历操作。其具体操作如下</p>

<p><img src="media/15282735197620/F24356323AB18A4707FDC96E96D35FB8.jpg" alt="F24356323AB18A4707FDC96E96D35FB8"/></p>

<p>在上面的例子中，<code>FamilyMember</code> 这个枚举类型在实现CaseIterable协议之后， swift自动为其添加了静态变量</p>

<pre><code>static var allCase: [FamilyMember] {
    return  [.father, .mother, .brother, .sister]
}
</code></pre>

<p>但是需要注意的是，对于枚举类型中有关联变量的情况，系统不会自动实现allCase。</p>

<p>比如 下图中<code>case porsche(convertible: Bool)</code>涉及了关联变量。这种情况下，需要像图中的注释掉的代码那样自己生成 。</p>

<p><img src="media/15282735197620/4CC5806A78B51C75CA0789FB03A1D13D.jpg" alt="4CC5806A78B51C75CA0789FB03A1D13D"/></p>

<h3 id="toc_6">随机数生成以及打乱操作</h3>

<p>过去我们一般使用的随机数生成操作</p>

<pre><code>1+(arc4random() % 6) //生成1-6之间的随机数
</code></pre>

<p>swift4.2中提供的新的方法</p>

<pre><code>Int.random(in: 0..&lt;10)
Float.random(in: 0..&lt;1)
[&quot;1&quot;,&quot;he&quot;,&quot;she&quot;,&quot;we&quot;].randomElement()! //选举出一个随机的
[&quot;1&quot;,&quot;he&quot;,&quot;she&quot;,&quot;we&quot;].shuffled()   // 打乱顺序，重新组合
</code></pre>

<p>除了系统提供的随机数生成方法，我们也可以让系统调用我们自己写的随机数生成算法。<br/>
需要实现协议<code>RandomNumberGenerator</code></p>

<pre><code>struct PrivateRandom: RandomNumberGenerator {...} //定义自己的随机数生成方式
var pr = PrivateRandom()
Int.random(in: 0..&lt;10, using: &amp;pr) //按照自己的随机数生成方法进行生成
</code></pre>

<h3 id="toc_7">Enhanced conditional conformances</h3>

<p>conditional conformances 允许在只有在特定条件满足时，才实现某种协议</p>

<p>比如说</p>

<pre><code>
protocol Purchaseable {
    func buy()
}

struct Book: Purchaseable {
    func buy(){
     print(&quot;You bought a book&quot;)
    }
}

extension Array: Purchaseable where Element: Purchaseable {
    func buy(){
    
    }
}
</code></pre>

<h4 id="toc_8">运行时的类型询问</h4>

<p>但是如果在运行时 去询问这个array时，会出现crash的情况（因为默认把array定义为any）。<br/>
这个情况在Swift4.2中得到解决。</p>

<p>举例说明<br/>
<img src="media/15282735197620/F9E6BB62AB0D7F29BAEC7E1428ECD376.jpg" alt="F9E6BB62AB0D7F29BAEC7E1428ECD376"/></p>

<h4 id="toc_9">Optional、Array、Dictionary等对协议的默认实现</h4>

<p>在swift4.2之前，如果我们要对 两个容器是否相等进行判定，通常要手动实现Equatable协议。</p>

<p><img src="media/15282735197620/43EF202AEED4513984A2C30BDA907EAB.jpg" alt="43EF202AEED4513984A2C30BDA907EAB"/></p>

<p>在swift4.2中，对于这些容易类型， swift已经为我们做好了处理。</p>

<p><img src="media/15282735197620/A9F4B891E7C0A3D7C242ABE9838204AD.png" alt="A9F4B891E7C0A3D7C242ABE9838204AD"/></p>

<p><img src="media/15282735197620/170E2367105A5EB8FBBF90FF4D0184C6.png" alt="170E2367105A5EB8FBBF90FF4D0184"/></p>

<p><strong>未完待续</strong></p>

<h2 id="toc_10">Hashable（未完待续）</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[踩坑记录]]></title>
    <link href="iginkgo.cn/15282672319466.html"/>
    <updated>2018-06-06T14:40:31+08:00</updated>
    <id>iginkgo.cn/15282672319466.html</id>
    <content type="html"><![CDATA[
<!--more-->

<h3 id="toc_0">问题1  使用 Leaks检查项目内存泄漏，崩溃的问题</h3>

<p>问题描述</p>

<p>进入Leaks模拟器或者真机app，进入30s左右就出现崩溃的现象，但是正常运行app没有问题</p>

<p><a href="">参考资料</a><br/>
最后找到解决方案：<br/>
进入leaks之后，在开启任务前，<br/>
通过操作<code>file</code> -&gt; <code>recordOptions</code> -&gt; <code>recordCount</code> 取消选择</p>

<h3 id="toc_1">问题2 对于约束的判定</h3>

<p>应用场景： 一个superview 加入 一个子view-UITableView。<br/>
在后续需要找到tableView的顶部约束并改变其值，使之发生改变。</p>

<pre><code>  self.view.constraints.foreach { (const) in
    if const.firstAttribute == NSLayoutAttribute.top.
        let view = const.firstItem as? UITableView,
            view = self.tableView {
            //TODO: 此处已识别，do sth
            }
  }
</code></pre>

<p>在这对关系中 const中的item1是UITableView，item2是superView<br/>
由于tableView的位置需要通过 superView来进行确定。<br/>
在最初添加约束时， <code>superView.addConstraints(...)</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode提速]]></title>
    <link href="iginkgo.cn/15209408664766.html"/>
    <updated>2018-03-13T19:34:26+08:00</updated>
    <id>iginkgo.cn/15209408664766.html</id>
    <content type="html"><![CDATA[
<p>如何更加快速的使用Xcode</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">1.把DeriveData放在内存中</h2>

<p><a href="http://blog.csdn.net/qq_30513483/article/details/70600301">相关地址</a></p>

<p>相关思路<br/>
1. 配置ram，让ram开辟出一块内存专门供Xcode使用<br/>
2. 连接Xcode，让Xcode连接到我们开辟出的专属内存中</p>

<p>方案<br/>
1.创建<code>.sh</code>文件</p>

<pre><code>#!/bin/bash
RAMDISK=”ramdisk”
SIZE=1024         #size in MB for ramdisk.
diskutil erasevolume HFS+ $RAMDISK \
     `hdiutil attach -nomount ram://$[SIZE*2048]`
</code></pre>

<p>2.命令行中执行 <code>./ramdisk.sh</code>命令，执行该脚本</p>

<pre><code>//注意：如果出现`Permission denied`的情况，使用
chmod 777 aa.sh
</code></pre>

<p>3.发现 ./Volume/ 下出现了一个新的内存空间</p>

<p>4.Xcode-&gt;Preference-&gt;Locations-&gt;Location Tab中 <br/>
DeriveData 目录选定为 Custom，然后路径为 /Volumes/“ramdisk”/DeriveData</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode基本操作]]></title>
    <link href="iginkgo.cn/15209407678838.html"/>
    <updated>2018-03-13T19:32:47+08:00</updated>
    <id>iginkgo.cn/15209407678838.html</id>
    <content type="html"><![CDATA[
<p>Xcode的基本操作、快捷键、调试</p>

<span id="more"></span><!-- more -->

<p>注意：<a href="http://www.cocoachina.com/ios/20141225/10761.html">原地址在此</a>,下面部分纯粹为个人记忆摘抄。</p>

<ul>
<li>
<a href="#toc_0">偏好设置</a>
</li>
<li>
<a href="#toc_1">代码阅读(快捷键)</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_2">View Navigator</a>
</li>
<li>
<a href="#toc_3">View Editor Organization</a>
</li>
<li>
<a href="#toc_4">Focus Switch</a>
</li>
<li>
<a href="#toc_5">Symbol Jump</a>
</li>
<li>
<a href="#toc_6">Symbol Navigator</a>
</li>
<li>
<a href="#toc_7">Help</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_8">代码编辑</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_9">File | New</a>
</li>
<li>
<a href="#toc_10">Text Editing</a>
</li>
<li>
<a href="#toc_11">Eidtor Window/Tab Switch</a>
</li>
<li>
<a href="#toc_12">Code Folding</a>
</li>
<li>
<a href="#toc_13">Console &amp; Scheme</a>
</li>
<li>
<a href="#toc_14">Gutter &amp; Ribbon</a>
</li>
<li>
<a href="#toc_15">Auto Completion</a>
</li>
<li>
<a href="#toc_16">Find &amp; Replace</a>
</li>
<li>
<a href="#toc_17">辅助编辑（Assistant Editor）</a>
</li>
<li>
<a href="#toc_18">环境变量（Build Setting Macros）</a>
<ul>
<li>
<a href="#toc_19">（1）查看环境变量宏</a>
</li>
<li>
<a href="#toc_20">（2）Xcode5(Mac OS X 10.9)的部分环境变量</a>
</li>
<li>
<a href="#toc_21">（3）设置环境变量</a>
</li>
</ul>
</li>
<li>
<a href="#toc_22">运行调试</a>
</li>
<li>
<a href="#toc_23">Watch</a>
</li>
<li>
<a href="#toc_24">lldb调试命令：</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_25">参考</a>
</li>
</ul>


<p><img src="media/15209407678838/Xcode%E7%95%8C%E9%9D%A2.png" alt="Xcode界面"/></p>

<h2 id="toc_0">偏好设置</h2>

<p>通过“command+,”快捷键或”Xcode|Preferences”菜单呼出偏好设置。</p>

<p>（1）主题及字体（Preferences-&gt;Fonts &amp; Colors）</p>

<p>选中一种主题（theme），例如“Midnight”，然后shift选择Source Editor/Console中的所有项，点击Fonts设置字体。Xcode默认字体为menlo，可选Consolas、Monaco等其他等宽字体。</p>

<p>（2）文本编辑配置（Preferences-&gt;Text Editing）<br/>
<img src="media/15209407678838/Editing.png" alt="Editing"/></p>

<ul>
<li>Show Line Numbers：在gutter中显示行号。</li>
<li>Code folding ribbon：显示折叠ribbon。</li>
<li>Page guide at column：显示一行最多支持80个字符的提示分割线。
Indentation：</li>
</ul>

<p>Prefer indent using：Spaces（为保持一致的视觉呈现和行末注释对齐，建议使用空格）<br/>
Tab width：4 spaces（tabexpand，1个tab=4个空格）<br/>
Indent width：4 spaces（自动缩进步长=4个空格）<br/>
（3）SCM（Preferences-&gt;Source Control）</p>

<p>Enable Source Control：启用/禁用XCode自带Source Control Manager(SCM)。</p>

<p>（4）SDK/Simulator（Preferences-&gt;Downloads）</p>

<p>Downloads-&gt;Components：可下载SDK和Simulator。</p>

<p>（5）构建输出目录（Preferences-&gt;Locations-&gt;Locations）</p>

<ul>
<li>当选择为Default时，Derived Data的目录为~/Library/Developer/Xcode/DerivedData。</li>
<li>当选择为Relative时，Derived Data的目录为当前.xcodeproj所在的目录。</li>
<li>当选择为Custom时，Derived Data的目录需自定义。</li>
</ul>

<p>不建议使用绝对路径，因为写死之后，换环境或换平台，又要重新修改路径，建议使用相对路径（Relative）。</p>

<h2 id="toc_1">代码阅读(快捷键)</h2>

<h4 id="toc_2">View Navigator</h4>

<p>command+0：Show/Hide left tool panel</p>

<p>command+1-8：Project/Symbol/Find/Issue/Test/Debug/Breakpoint/Log Navigator</p>

<p>option+command+0：Show/Hide right tool panel</p>

<p>option+command+1/2：show the file/quick help inspector</p>

<h4 id="toc_3">View Editor Organization</h4>

<p>control+1：Show Related Items（例如Superclasses/Subclasses、Callers/Callees、Protocol Implementor/Implemented、Includes/Included By）。可输入实时搜索匹配。</p>

<p>control+2/3：Show Previous/Next History。可输入实时搜索匹配。</p>

<p>control+4：Show Top Level Items。</p>

<p>control+5：Show Group Files（当前文件夹内的所有文件）。可输入实时搜索匹配。</p>

<p>control+6：Show Document Items（当前文件的Symbols）。可输入实时搜索匹配。</p>

<p>可直接选中符号，然后“Navigate-&gt;Reveal in Symbol Navigator”，打开该接口的符号列表。</p>

<h4 id="toc_4">Focus Switch</h4>

<p>command+J：焦点切换（Move Focus），可配合鼠标和方向键。带‘+’的“Move focus to a new assistant editor”可以快速在辅助编辑窗口中打开头文件（<em>.h）/实现文件（</em>.m，*.mm）。</p>

<p>shift+command+J：在项目导航中定位当前文件（Reveal in Project Navigator）。</p>

<h4 id="toc_5">Symbol Jump</h4>

<p>control+command+↑/↓：切换头文件/实现文件（switch between a source file (.m,<em>.mm,</em>.cc) and the associated header file(.h)）。</p>

<p>shift+command+O：Open Quickly，可快速查找文件、符号。</p>

<p>command+点击Editor中选中的符号：跳转到符号定义（jump to definition）。</p>

<p>control+command+J：跳转到指定符号的定义处或实现处（Go to Declaration/Definition）。有时工程正在Loading、Indexing或Processing files时，“command+点击”无法响应，此时可试试control+command+J。</p>

<p>在Project Navigator中选中文件右键或通过菜单“File-&gt;Show in Finder”：在Finder中定位该文件。</p>

<h4 id="toc_6">Symbol Navigator</h4>

<p>command+点击Editor中选中的非单一层次定义符号：Show in Symbol Navigator:</p>

<p>filter0：底部输入符号（show symbols with matching name）= filter1 result+filter3 result</p>

<p>filter1：show only class and protocol symbols (hide other global symbol types)，包括project和system层次。</p>

<p>filter2：show only project-defined symbols，过滤显示当前工程中的符号。filter2的结果是filter1的子集，较常用。</p>

<p>filter3：show only containers(hide members)，过滤显示包含该单词的符号。</p>

<h4 id="toc_7">Help</h4>

<p>option+点按：查看选中符号的帮助提示（Quick Help for Selected Item）。</p>

<p>option+双击：打开选中符号的帮助文档。</p>

<h2 id="toc_8">代码编辑</h2>

<h4 id="toc_9">File | New</h4>

<p>control+command+N：File | New | Workspace</p>

<p>shift+command+N：File | New | Project</p>

<h4 id="toc_10">Text Editing</h4>

<p>command+[/]：向前/向后缩进</p>

<p>option+command+[/]：Move Line Up/Down</p>

<p>command+/：注释选中的代码</p>

<p>Parentheses/Brackets/Braces Matching：双击某个分隔符（如()、[]、{} 等），Xcode会选中匹配代码块。</p>

<h4 id="toc_11">Eidtor Window/Tab Switch</h4>

<p>command+shift+[/]：切换标签页</p>

<p>单指左右滑动（control+command+←/→）：在单标签页打开的多个文件间切换</p>

<h4 id="toc_12">Code Folding</h4>

<p>option+command+←/→：折叠当前代码块</p>

<p>option+shift+command+←/→：折叠该文件内所有代码块（方法/函数）</p>

<h4 id="toc_13">Console &amp; Scheme</h4>

<p>shift+command+Y：显示控制台（Show/Hide the debug area）</p>

<p>option+command+R：编辑配置（Edit Scheme）</p>

<h4 id="toc_14">Gutter &amp; Ribbon</h4>

<p><img src="media/15209407678838/Gutter-Ribbon.png" alt="Gutter-Ribbon"/></p>

<p>焦点列：灰色深度与代码嵌套深度相关，鼠标悬停可突出显示右侧相应代码块，鼠标单击可折叠右侧相应代码块（Code Folding）。</p>

<p>说明：从左到右，依次是“导航窗格（Navigator）-&gt;边列（Gutter）-&gt;焦点列（Focus</p>

<p>Ribbon）-&gt;代码编辑窗口（Standard Editor）”。</p>

<h4 id="toc_15">Auto Completion</h4>

<p>esc（command+.）：就当前输入上下文呼出/隐藏Auto</p>

<p>Completion提示：上下方向键在提示中选择选项，enter(return)选中，tab可一截一截匹配；tab可在各个占位符之间移动。</p>

<p>输入Objective-C对象及 ]，自动完成中缀符(infixnatation)包围。</p>

<h4 id="toc_16">Find &amp; Replace</h4>

<p>command+F：当前文件查找。</p>

<p>option+command+F：当前文件替换。</p>

<p>Find：可指定查找内容（Text/References/Definitions/Regular Expression）；<br/>
放大镜：下拉可查看最近查找历史；<br/>
In Project：查找范围（可指定Group）；<br/>
Text：匹配规则（可指定Containing，Matching，Starting with，Ending with）；<br/>
Case：是否区分大小写（可指定 Matching/Ignoring）。<br/>
shift+command+F（command+3）：全局查找。也可以在选择符号后，右键（control+点击）-&gt;Find Selected Text in workspace...</p>

<p>option+shift+command+F：全局替换。</p>

<p>Replace：逐个替换；<br/>
All：所有替换；<br/>
Done：替换完成。</p>

<h4 id="toc_17">辅助编辑（Assistant Editor）</h4>

<p>Assistant Editor有点类似VC中的Code Definition Window。</p>

<p>option+command+enter：打开Assistant Editor。</p>

<p>command+enter：关闭Assistant Editor。</p>

<p>使用快捷键进行切换或跳转动作时，若同时按下option可以在辅助编辑窗口中打开相应文件或符号（For optional navigation (Option-clicking or Option-choosing a file), opens the file in a new Assistant editor pane.）。若在辅助窗口中操作，则在主窗口（Standard Editor）中打开。</p>

<ul>
<li>option+点击Project Navigator中选中的文件：在辅助编辑窗口中打开选中文件。</li>
<li>option+command+点击Editor中选中的符号：在辅助编辑窗口中打开符号定义（jump to definition in assistant editor）。</li>
<li>option+control+command+↑/↓：在辅助窗口中打开对应的头文件（<em>.h）/实现文件（</em>.m,<em>.mm,</em>.cc）。
点击查看shift+command+O、shift+command+F（command+3）选中的文件或符号时，可同时按下option在辅助编辑窗口中打开。</li>
</ul>

<p>在control+1~6中打开选择结果时，均可同时按下option在辅助编辑窗口中打开。</p>

<p>若在按下option的同时按下shift通常会出现一个导航窗格，可选择在new window/tab/assistant-editor显示打开。</p>

<p>ForOption-Shift navigation (Option-Shift-click or Option-Shift-choose a file), Xcode displays a graphical navigation chooser showing the current layout. The chooserprompts you to open the file in anyopen editor pane in any window and tab, or to open the file in anew editor pane, window, or tab.</p>

<p>20140219220929453.png</p>

<h4 id="toc_18">环境变量（Build Setting Macros）</h4>

<h5 id="toc_19">（1）查看环境变量宏</h5>

<p>命令行进入HelloWorld工程目录，执行xcodebuild命令并带上“-showBuildSettings”参数：</p>

<p>$ xcodebuild -project HelloWorld.xcodeproj -target HelloWorld -configuration Debug -showBuildSettings &gt; xcodebuild_showBuildSettings.txt</p>

<p>则xcodebuild_showBuildSettings.txt中保存了Build settings for action build and target &quot;HelloWorld”，其中dump了所有的环境变量。</p>

<h5 id="toc_20">（2）Xcode5(Mac OS X 10.9)的部分环境变量</h5>

<p>约定1：~=当前账户的HOME目录，例如“/Users/faner”。</p>

<p>约定2：build构建基础路径：BUILD_PATH = ~/Library/Developer/Xcode/DerivedData/Build。可通过“File-&gt;Project Settings”查看Derived Data Location。</p>

<p>约定3：环境变量宏（Build Setting Macros）引用格式：${MACRO}，同Build Phases Run Script中的语法。</p>

<p>下面是摘选自xcodebuild_showBuildSettings.txt的部分常用环境变量。</p>

<p><strong>(a) ARCH &amp; PLATFORM &amp; SDK</strong><br/>
ARCHS = i386</p>

<p>CURRENT_ARCH = i386</p>

<p>PLATFORM_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform</p>

<p>PLATFORM_NAME = macosx</p>

<p>SDKROOT = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk</p>

<p>SDK_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk</p>

<p>SDK_NAME = macosx10.9</p>

<p><strong>(b) PROJECT &amp; SOURCE</strong></p>

<p>PROJECT = HelloWorld</p>

<p>PROJECT_DIR =~/Projects/Learn Objective-C/HelloWorld</p>

<p>PROJECT_FILE_PATH =${PROJECT_DIR}/HelloWorld.xcodeproj</p>

<p>PROJECT_NAME = HelloWorld</p>

<p>SOURCE_ROOT =${PROJECT_DIR}</p>

<p>SRCROOT =${PROJECT_DIR}</p>

<p><strong>(c) BUILD &amp; CONFIGURATION</strong></p>

<p>BUILD_DIR =BUILD_PATH/Products</p>

<p>BUILD_ROOT =BUILD_PATH/Products</p>

<p>BUILT_PRODUCTS_DIR =BUILD_PATH/Products/Debug</p>

<p>CONFIGURATION = Debug</p>

<p>CONFIGURATION_BUILD_DIR =BUILD_PATH/Products/Debug</p>

<p>CONFIGURATION_TEMP_DIR =BUILD_PATH/Intermediates/HelloWorld.build/Debug</p>

<p><strong>(d) PRODUCT &amp; TARGET</strong></p>

<p>PRODUCT_NAME = HelloWorld</p>

<p>PRODUCT_TYPE = com.apple.product-type.tool// Project Template: Command Line Tool</p>

<p>TARGET_BUILD_DIR =BUILD_PATH/Products/Debug</p>

<p>TARGET_NAME = HelloWorld</p>

<h5 id="toc_21">（3）设置环境变量</h5>

<p>Product -&gt; Edit Scheme（option+command+R）-&gt;Arguments-&gt;Environment Variables中可以添加自定义环境变量（Name为名称，Value为值）。</p>

<h4 id="toc_22">运行调试</h4>

<p>（1）Console</p>

<p>shift+command+Y：显示控制台（Show/Hide the debug area）</p>

<p>shift + command + K：清除控制台（Clean）</p>

<p>（2）Build</p>

<p>Product -&gt; Edit Scheme（option+command+R）-&gt;Info-&gt;Build Configuration：选择生成版本（Debug or Release）</p>

<p>command + B：构建（Buid）</p>

<p>（3）Target</p>

<p>一个Target是指在一个Project中构建的一个产品，它包含了构建该产品的所有文件，以及如何构建该产品的配置。</p>

<p>一个定义好构建过程的Target成为一个Scheme，可在Scheme中定义Target的六种构建过程：Build/Run/Test/Profile/Analyze/Archive。</p>

<p>Product -&gt; Edit Scheme（option+command+R）-&gt;Manage Schemes可对Scheme的六种构建过程进行配置（可配置项包括Info、Arguments、Options）。</p>

<p>在Project Navigator中选中某个xcodeproj（例如QQ.xcodeproj），将进入Project Setting页面，可点击左侧图标show/hide project and targets list：</p>

<p>0012.png</p>

<p>点击targets项可分别设置各target的Build Settings；右击可对target进行delete。</p>

<p>（4）Issue &amp; Errors</p>

<p>编译错误（error）和警告（warning）过多时，只显示编译错误：</p>

<p>0013.png</p>

<p>点击底端的感叹号，即可只显示编译错误，忽略编译警告：</p>

<p>0014.png</p>

<p>（5）Run</p>

<p>command + R：运行（Run），可能会先编译。若按下control直接运行上次build的product（Run Without Building）。</p>

<p>command + .：停止运行（Stop）</p>

<p>（6）Breakpoint</p>

<p>command + \：当前行设置/取消断点；通过鼠标点击蓝色断点来启用/禁用当前行断点。</p>

<p>command + Y：全局激活或禁用所有的断点，激活进入调试模式（此时断点蓝色可见）。</p>

<p>边列（Gutter）中的断点/警告可右键呼出Reveal in Breakpoint/Issue Navigator。</p>

<p>trick：编辑断点（Edit Breakpoint）：</p>

<p>Condition：设置断点的触发条件，例如“i==3”（注意不能有空格）表示当i等于3时该断点才会被触发。<br/>
Ignore：设置断点需要被忽略多少次才会中断，若设置成5则表示第6次遇到该断点时才触发。<br/>
Action：设置断点触发时的动作，可以为Debugger Command、Log Message、Shell Command或Sound。<br/>
例如可设置以下Debugger Command：</p>

<p>（1）读取std::string sig的内存buffer值：mem read sig.c_str() -c sig.size()；</p>

<p>（2）打印NSData实例sig：po sig</p>

<p>（7）Debug</p>

<p>F6：下一步（Step Over），逐过程单步调试，不进入函数体。</p>

<p>(fn+)F7：进入（Step Into）函数体。可能与多媒体键有冲突，故需要fn辅助。</p>

<p>(fn+)F8：跳出（Step Out）函数体。可能与多媒体键有冲突，例如呼叫iTunes，故需要fn辅助。</p>

<p>control+command+Y：逐断点（continue）继续执行。</p>

<p>trick：移动指令指针（Move the instruction pointer）：</p>

<p>0015.png</p>

<p>断点调试运行时，可以将绿色指针箭头（Line 47）移动到其他行（Line 49）或其他断点（Line 51）实现跳转执行。</p>

<h4 id="toc_23">Watch</h4>

<p>shift+command+M：Debug Workflow-&gt;View Memory。</p>

<p>command+K：Debug Workflow-&gt;Clear Console。</p>

<p>Debug Workflow-&gt;ShowDisassembly When Debugging，可进行汇编指令级调试。</p>

<p>trick：修改变量内存值（change memory value while debugging）：</p>

<p>调试运行时，可以在底部的调试窗口（Debug Area，可通过Shift+Command+Y呼出）右键某个变量，除了可以进行View Memory/View Value As之外，还可以选择Edit Value运行时编辑内存变量的值。</p>

<p>这种手动设置指定值，在调试某些难以复现的bug或进行边界测试非常有用，可以避免在验证某个问题时反复改值重新编译。</p>

<h4 id="toc_24">lldb调试命令：</h4>

<p>n/next：step over；<br/>
s/step：step into；<br/>
finish：step out；<br/>
c/continue：goto next breakpoint；<br/>
expr/expression：Evaluate a C/ObjC/C++ expression（动态执行C/ObjC/C++表达式）；<br/>
p/print/expr/expression：print as a C/C++ basic variable；<br/>
po/expr -O/expression -O：Print as an Objective-C object；<br/>
call：调用。其实上述p/po后接表达式(expression)也有调用的功能，一般只在不需要显式输出，或是无返回值时使用call，用于动态调试插入调用代码。<br/>
    例如可以在viewDidLoad:里面设置断点，然后在程序中断的时候输入以下命令：</p>

<pre><code>  call [self.view setBackgroundColor:[UIColor redColor]]
</code></pre>

<p>继续运行程序，view的背景颜色将变成红色！</p>

<p>bt（backtrace），打印当前调用堆栈（crash堆栈），“bt all”可打印所有thread的堆栈（相当于command+6的Debug Session Navigation）。<br/>
image：可用于寻址，有多个组合命令，比较实用的一种用法是寻找栈地址对应的代码（行）位置。<br/>
例如某个UITableView总共有2个section，当其引用的currentSection.index≥2时将会引起[UITableView rectForHeaderInSection:]调用异常，可使用expr动态改值制造crash场景模拟调试。</p>

<p>此时crash时的控制台bt显示异常出现在应用层代码“0x00d055b8 - [FACategoryTableView FACategorySectionHeaderDidTouched:] + 744”处（其中0x00d055b8为当前栈(代码段)偏移量，744为栈帧偏移量——PC指针相对函数入口的偏移）。</p>

<p>那么具体是FACategoryTableView.m文件哪一行代码调用引起的异常呢？此时通过“image lookup --address”后接bt的call stack中的代码段偏移地址（0x00d055b8）即可定位出异常调用的代码行位置。</p>

<p>x/memory read：dump指定地址的内存（Read from the memory of the process being debugged），后接起止地址或-c指定count加起始地址。可help mem read查看帮助：<br/>
Syntax:</p>

<pre><code> memory read[]
</code></pre>

<p>Command Options Usage:</p>

<pre><code>size指定内存块（block/item）的大小，默认为1byte。

--size)：The size in bytes to use when displaying with the selected format.
</code></pre>

<p>count指定内存块（block/item）的个数，可配合起始地址使用。</p>

<p>-c( --count)：The number of total items to display.</p>

<p>format指定内容显示格式，格式符同print：c-char，s-string，d-decimal，x-hex。</p>

<p>-f( --format)：Specify a format to be used for display.</p>

<p>Command Samples:</p>

<p>（a）起止地址</p>

<p>(lldb)mem read 0x10b88f0c 0x10b88f0c+9</p>

<pre><code>0x10b88f0c: 39 38 37 36 35 34 33 32 31                       987654321
</code></pre>

<p>（b）起始地址+内存块count</p>

<p>(lldb)mem read 0x10b88f0c -c 9</p>

<pre><code>0x10b88f0c: 39 38 37 36 35 34 33 32 31                       987654321
</code></pre>

<p>（c）起始地址+内存块size+内存块count（dump hex format）</p>

<p>(lldb)memory read -s 1 -f x -c 9 0x10b88f0c</p>

<p>0x10b88f0c: 0x39 0x38 0x37 0x36 0x35 0x34 0x33 0x32</p>

<p>0x10b88f14: 0x31</p>

<p>（d）起始地址+内存块size+内存块count（dump char format）</p>

<p>(lldb)memory read -s 1 -f c -c 9 0x10b88f0c</p>

<p>0x10b88f0c: 987654321</p>

<p>（e）起始地址+内存块size+内存块count（dump string format）</p>

<p>(lldb)mem read 0x10b5cf2c -f s -c 1</p>

<p>0x10b88f0c: &quot;987654321&quot;</p>

<p>（f）起始地址+内存块size+内存块count（dump int format）</p>

<p>(lldb)memory read -s 4 -f x -c 3 0x10b88f0c</p>

<p>0x10b88f0c: 0x36373839 0x32333435 0x109f0031</p>

<p>memory write：改写指定地址的内存（Write to the memory of the process being debugged）。可help mem write查看帮助：<br/>
   Syntax: memory write</p>

<p>[[...]]<br/>
（10）启用NSZombieEnabled调试EXC_BAD_ACCESS</p>

<p>当你对已释放的对象发送消息（90%的可能是对引用计数为0的对象再release）或release那些autorelease对象时，就会出现报EXC_BAD_ACCESS这样的错误。</p>

<p>默认设置下 Xcode不会给你定位具体是哪一行代码不该去使用已释放的对象，或者release用错了。</p>

<p>Product -&gt; Edit Scheme（option+command+R） -&gt; Diagnostics ，勾选“Objective-C”之后的“Enable Zombie Objects”。</p>

<p>设置NSZombieEnabled环境变量后，一个对象销毁时会被转化为_NSZombie；设置NSZombieEnabled后，当你向一个已经释放的对象发送消息，这个对象就不只是报EXC_BAD_ACCESS Crash，还会放出一个错误消息，然后以一种可预测的可以产生debug断点的方式消失， 因此我们可以找到具体或者大概是哪个对象被错误的释放或引用了。</p>

<p>注意：NSZombieEnabled只能在调试的时候使用，千万不要忘记在产品发布的时候去掉，因为NSZombieEnabled不会真正去释放dealloc对象的内存，一直开启后果自负！</p>

<h2 id="toc_25">参考</h2>

<p><a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/xcode_help-command_shortcuts/Introduction/Introduction.html">《Xcode Keyboard Shortcuts and Gestures》</a></p>

<p><a href="http://www.cocoachina.com/ios/20140225/7882.html">《Xcode Key Bindings &amp; Gestures》</a><br/>
<a href="http://www.cocoachina.com/industry/20140613/8816.html">《提升Xcode效率的小技巧》</a></p>

<p><a href="http://blog.csdn.net/shinancao666/article/details/13627979">《Xcode的文件组织》</a></p>

<p><a href="http://www.cnblogs.com/xiaodao/archive/2012/03/28/2422091.html">《Xcode环境变量及路径设置》</a><br/>
<a href="http://blog.csdn.net/fengsh998/article/details/8868871">《Xcode构建输出目录》</a></p>

<p><a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-basics.html">《LLDB Quick Start Guide》</a><br/>
<a href="http://lldb.llvm.org/lldb-gdb.html">《LLDB to GDB Command Map》</a><br/>
<a href="http://blog.163.com/jin_yuanwen/blog/static/19757915220131238104514">《Xcode gdb/lldb调试命令》</a></p>

<p><a href="http://blog.sina.com.cn/s/blog_6dce99b10101gwwo.html">《Xcode LLDB Debug教程》</a><a href="http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/">《LLDB调试命令初探》</a><a href="http://blog.csdn.net/cuiweijie3/article/details/8778198">《iOS应用崩溃日志揭秘》</a><a href="http://www.cnblogs.com/alario/archive/2012/03/27/2419710.html">《经营你的iOS应用日志》</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[viewController的生命周期]]></title>
    <link href="iginkgo.cn/15209406714961.html"/>
    <updated>2018-03-13T19:31:11+08:00</updated>
    <id>iginkgo.cn/15209406714961.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<p>在开发中遇到这样一个问题， viewControllerA向viewControllerB进行切换时，我需要在离开viewControllerA时，关闭全局控制器managerPlayer， 然后进入viewControllerB后，再次开启。返回之后继续进行使用managerPlayer进行视频播放。</p>

<p>因此我需要在 viewWillAppear()<br/>
           viewWillDisapper()进行设定。</p>

<p>突发好奇，我想整理一下，两个viewController进行切换时，其生命周期的调用情况，以及两者的生命周期在调用时的对应关系。</p>

<p>先发一下打印信息</p>

<pre><code>viewControllerA  viewDidLoad()
viewControllerA  viewWillAppear()
viewControllerA  viewWillLayoutSubviews()
viewControllerA  viewDidLayoutSubviews()
viewControllerA  viewDidAppear()

此处点击进行controller切换

viewControllerB  viewDidLoad()
viewControllerA  viewWillDisappear()
viewControllerB  viewWillAppear()
viewControllerB  viewWillLayoutSubViews()
viewControllerB  viewDidLayoutSubviews()
viewControllerA  viewDidDisappear()
viewControllerB  viewDidAppear()

</code></pre>

<p>然后考虑一下对于一个viewController中完整的生命周期</p>

<p><img src="media/15209406714961/life.png" alt="life"/></p>

<p>对于整个生命周期的方法进行总结</p>

<p><code>init</code> 进行整体的初始化<br/>
<code>loadView</code> 对于页面中的view进行了初始化,之后可以获取self.view的实例<br/>
<code>viewDidLoad</code>此时可以获取view以及其子类view，但是superView还没有。<br/>
<code>viewWillAppear</code> view即将显示的节点。每次显示该页面之前都会进入该时间节点   这里的尺寸已经都是实际的了么？<br/>
<code>viewDidAppear</code> view已经显示。（被加到另外一个view中）</p>

<p><code>viewWillDisappear</code> view即将消失 此时还没有调用 removeFromSuperView<br/>
<code>viewDidDisappear</code> view已经从superView中移除<br/>
<code>viewDidUnload</code> 干啥？</p>

<p>viewController主要负责的职能：<br/>
1. 该努力内部view的加载、显示、卸载<br/>
2. 负责与其他viewController的通信和协调</p>

<p>注意：</p>

<blockquote>
<p>Note: When overriding the loadView method to create your views programmatically, you should not call super. Doing so initiates the default view-loading behavior and usually just wastes CPU cycles. Your own implementation of the loadView method should do all the work that is needed to create a root view and subviews for your view controller.</p>

<p>注意： 如果需要重写loadView方法来创建你的view时，在loadView方法中不应该调用super，如果调用该方法的话可能会影响CPU性能。</p>
</blockquote>

<p>loadView与viewDidload的区别是 ，loadView时view还没有生成， viewDidLoad时，view已经生成了。loadView只会被调用一次，但是viewDidLoad可能会被调用多次（view可能多次加载），当view被添加到其他view中之前，会调用viewWillAppear。 当view不再使用时，收到内存警告时，viewController会将view释放并将其指向为nil。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tools]]></title>
    <link href="iginkgo.cn/15209405889264.html"/>
    <updated>2018-03-13T19:29:48+08:00</updated>
    <id>iginkgo.cn/15209405889264.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">code</h2>

<p><a href="http://asciiflow.com/">使用注释画图</a><br/>
<a href="https://www.processon.com/login">绘制流程图</a><br/>
<a href="https://www.appsight.io/">Find SDKs &amp; services used by iOS mobile apps</a><br/>
<a href="https://aso100.com/">iOS app排名</a></p>

<h2 id="toc_1">life</h2>

<p><a href="http://ip.taobao.com/index.php">ip地址查询</a><br/>
<a href="http://app2.sfda.gov.cn/datasearchp/gzcxSearch.do?formRender=cx&amp;page=1">药监局查询正品</a><br/>
<a href="http://sswz.spb.gov.cn/">快递投诉</a><br/>
<a href="https://github.com/cn">中国资料数据库 github开源</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《被讨厌的勇气》]]></title>
    <link href="iginkgo.cn/15209404638621.html"/>
    <updated>2018-03-13T19:27:43+08:00</updated>
    <id>iginkgo.cn/15209404638621.html</id>
    <content type="html"><![CDATA[
<p>中文名《被讨厌的勇气》</p>

<span id="more"></span><!-- more -->

<p>大约花了3天的时间，25-30个番茄时钟的时间细细读完了日本作家岸建一郎的书《被讨厌的勇气》, 刷了一遍自己的认知。<br/>
<img src="https://img1.doubanio.com/lpic/s29237648.jpg" alt="被讨厌的勇气"/></p>

<p>全书大体是一个 “目的论”为核心的思想，提倡充分发挥自己的主观能动性、利他但是不以他人的期待为约束，不拘泥过去，不过度关注未来，活在当下。<br/>
现做一下大体的总结，第一次阅读比较粗陋，今后还会继续修缮。</p>

<p><img src="media/15209404638621/TheCourageToBeHated.png" alt="TheCourageToBeHated"/></p>

]]></content>
  </entry>
  
</feed>
